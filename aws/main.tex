% !TEX root = ../main.tex

%tools
% \newcommand{\souffle}{\textsc{Souffl\'{e}}\xspace}
% \newcommand{\vampire}{\textsc{Vampire}\xspace}
% \newcommand{\eprover}{\textsc{E}\xspace}
% \newcommand{\spass}{\textsc{Spass}\xspace}

\newcommand{\souffle}{Souffl\'{e}\xspace}
\newcommand{\vampire}{Vampire\xspace}
\newcommand{\eprover}{E\xspace}
\newcommand{\spass}{Spass\xspace}


%languages
% \newcommand{\Datalog}{\textsc{Datalog}\xspace}
\newcommand{\Datalog}{Datalog\xspace}

%datalog notation
% \mathchardef\mhyphen="2D
% \makeatletter
% \newcommand*{\rl}{\mathrel{\texttt{:}\hspace{-0.075em}\mhyphen}}
% \makeatother
\newcommand*{\rl}{\mathrel{\leftarrow}}
\newcommand*{\comma}{\mathrel{\wedge}}

\renewcommand*{\phi}{\varphi}

\newcommand{\typedRel}[1]{\mathit{#1}}
\newcommand{\typed}[2]{\typedRel{#1}({#2})}

% Notation for Horn clauses definitions
\newcommand{\pred}[1]{\mathit{#1}} % predicates
\newcommand{\const}[1]{\mathrm{#1}} % constants
\newcommand{\type}[1]{\mathrm{#1}} % types

\newcommand{\sem}[1]{(#1)} % types

%-------------------------------------------------------------------------------
\section{Introduction}
\label{sect:aws/introduction}
Computer networks are typically built from a variety of specialized heterogeneous devices running complex distributed protocols. Network administrators, responsible for operability of a network, must configure and deploy every protocol separately on each individual device. In an effort to simplify this task, \emph{software-defined networking} (SDN)~\cite{SDN} has been proposed as a modern alternative. SDN provides an layer of software that is installed on each of the network devices and a logically-centralized controller that manages connectivity settings of each device. Administrators can therefore manage networks at a higher level of abstraction by programming them from the controller, typically in a domain specific language~\cite{DBLP:journals/cm/FosterGRSFKMRRSWH13}. The SDN architecture is often credited with flexibility and ease of maintenance compared to traditional networks~\cite{benzekki2016software}.

Modern platforms for cloud computing such as Amazon Elastic Compute Cloud, Google Compute Engine and Azure Virtual Machines offer their users means of configuring \emph{virtual private cloud} (VPC) networks in the style of SDN. Administrators of such networks use a centralized control panel or a specialized API to launch network nodes, set up subnets and route tables, and tune connectivity and security settings of the network. Despite the increase of usability provided by the cloud platforms, VPC networks remain prone to misconfigurations. These misconfigurations are caused by the complexity of large-scale enterprise networks and might lead to downtimes and breaches of security. Discovering such misconfigurations in industrial-sized networks is both labor-intensive and computationally hard. %Therefore, verifying the correctness of network configurations is an important and challenging task.

The presense of a centralized network configuration facilitates automated analysis and synthesis of SDN networks. Indeed, several tools have been developed~\cite{batfish,jayaraman2014automated,DBLP:conf/icdcit/BjornerJ15,DBLP:conf/pldi/BallBGIKSSV14,Veriflow,ConfigChecker,Anteater,DBLP:conf/cav/El-HassanyTVV17} in an effort to verify various SDN components. These tools employ specialized algorithms~\cite{Veriflow} as well as general purpose reasoning engines such as \Datalog~\cite{muZ, DBLP:conf/cav/El-HassanyTVV17}, BDD~\cite{ConfigChecker}, SMT~\cite{jayaraman2014automated,DBLP:conf/icdcit/BjornerJ15} 
and SAT~\cite{Anteater,DBLP:conf/pldi/BallBGIKSSV14}.

%
% Problem 1: Size of networks, \Datalog works good in this however certain subproblems are hard for datalog
%
Despite the vast body of available tools, the problem of practical verification of enterprise networks remains a 
challenge. Firstly, the size and intricacy of modern industrial-sized networks results in very difficult constraint 
satisfaction problems. While most network verification 
tools depend on a single constraint solving paradigm, we find that no single solver achieves best performance on all 
verification problems. Secondly, general purpose solvers are very 
performance-sensitive to problem encodings. Effective encodings are often a ``black art'' for users, resulting in tedious trial 
and error for a user without a good understanding of the implementation of the underlying solver.

\EK{Our ultimate goal is to design a portfolio of complementary constraint solvers... Our motivation for using a portfolio of solvers rather than a single solver is to leverage the advantages of different types of solvers on different types of properties.
}

In this work we check reachability properties of VPC networks using automated theorem provers for first-order logic.

\EK{We plan to integrate this approach in our ongoing work on portfolios.}

We are interested in checking properties that express whether the network traffic is able to flow between given nodes of a VPC network. The traffic flow in these networks is typically controlled by the rules assigned to various networking components provided by the cloud platform. These components include subnets, route tables, access control lists, internet gateways, and others. Let us illustrate these properties using the following example of a VPC network. 
\begin{figure*}[th]
\centering\includegraphics[width=1.0\textwidth]{./aws/fig/vpc.pdf}
\end{figure*}

This network consists of an internet gateway, two subnets ``Web'' and ``Database'' and three network nodes in each of them. Each of the subnets is assigned with a route table (on the right) and an access control list (ACL, on the left). The route tables allow the network traffic to flow between the subnets and between the ``Web'' subnet and the internet gateway. In other words, the network nodes in the ``Web'' subnet are accessible from the internet. An ACL consists of rules that filter the network traffic to and from its subnet. In our example, one of the ACL rules of the ``Database'' subnet forbids SSH access to its nodes, both directly and through an intermediate node.

In a realistic setting this network might grow over time and have more nodes, security and access rules added to it. A network administrator may want to make sure that the network retain certain properties after each change in its configuration. For example, the network administrator may want to check the following property.
\begin{example}\label{prop:bool-property}
All network nodes in the subnet ``Web'' can access all network nodes in the subnet ``Database''.
\end{example}

The network administrator might also want to know which networking components satisfy a given property, such as the ones in the following example.
\begin{example}\label{prop:list-property}
All network nodes that have the port 22 (SSH) accessible from the internet.
\end{example}

We will refer to questions that network administrators might want to answer, such as the ones in Examples~\ref{prop:bool-property} and \ref{prop:list-property}, as \emph{network questions}. In particular, we will refer to questions similar to Example~\ref{prop:bool-property} as \emph{boolean questions}, because an answer to them is ``yes'' or ``no'', and to questions similar to Example~\ref{prop:list-property} as \emph{list questions}, because an answer to them is a list of networking components. Each boolean question can be equivalently phrased as a list question such that the answer to the boolean question is ``yes'' iff the answer to the correspondent list questions is not empty. However, we distinguish these two types of questions because, as we show later, we can more efficiently answer them using different techniques.

Answering network questions manually might be tedious and error-prone in an industrial-size network. For this reason it is necessary to automate this task with specialized tools. In this work we employ finite model builders and saturation-based theorem provers. To this end, we build static models of VPC networks (Section~\ref{sect:aws/specification}), translate the network questions about these models to problems in first-order logic (Section~\ref{sect:aws/fol}), and check them with finite model builders and saturation-based theorem provers (Section~\ref{sect:aws/fol-provers}).



answer network questions by expressing them as problems in first-order logic and then solving these problems using .

we can more efficiently answer list questions with finite model builders and answer boolean questions with saturation-based theorem prover. This allows us to answer network questions more efficiently.

%The paper is organized as follows. Section~\ref{sect:aws/specification} describes the network reachability properties and the network models. Section \ref{sect:aws/fol} presents our translation of network properties for first-order theorem provers. Section~\ref{sect:aws/related} presents related work, and Section~\ref{sect:aws/conclusion} contains a discussion of this work and suggests future work.

\paragraph{Contributions.} Our contributions are summarized as follows: \begin{enumerate}
\item We explore efficient encodings for two types of backend solvers, including 
saturation-based solvers, which to the best of our knowledge, have not been used to verify networks
\item We provide a comparison of the backend solvers and classify their strengths and weaknesses.
\end{enumerate}

%-------------------------------------------------------------------------------
\section{Network Reachability Properties}
\label{sect:aws/specification}
We answer network questions \emph{statically}, that is, instead of sending packets in a network, we build a static model of the network and reason about properties of this model. Our \emph{network model} consists of two parts, the \emph{formal specification} and the \emph{snapshot} of the network. The specification formalizes the semantics of each of the components available in the network. For example, the formal specification describes how a route table directs network traffic in a subnet or in which order a firewall applies rules in an access control list. The snapshot describes the topology of the given network. For example, the snapshot contains the list of network nodes, subnets, and their route tables. Naturally, the formal specification in the model of each particular VPC network is the same, whereas the snapshot differs. We express network questions in the language of many-sorted first-order logic. In the remainder of this section we describe syntax and semantics of network models and network questions.

\EK{We might want to make it clear that the models and the queries are given to us. Otherwise we'd have to justify why we use Datalog for the spec and first-order logic for the queries.}

\subsection{Network Models}
\label{sect:aws/reachability/spec}
We formally specify networks in a logic programming style. A network model is a finite set of first-order Horn clauses. We disallow function symbols and allow stratified negation. We assume the plain logic programming semantics for these Horn clauses, defined in the standard way~\cite{}. In particular, we make the closed-world assumption and treat negation as failure. In addition, our network models use the theory of bit vectors to describe ports, IPv4 addresses, and subnet masks.

A \emph{signature} of the network model is a triple $(T, C, P),$ where $T$ is a set of \emph{types}, $C$ is a set of \emph{constants}, and $P$ is a set of \emph{predicates}. We assign each constant with a type $\tau\in T$ and each predicate with a type $\tau_1\times\ldots\times\tau_n$ $(n\ge0)$, where $\tau_i\in T$ for each $1\leq i \leq n$. We assume a countable infinite set of \emph{variables}. We assign each variable with a type $\tau\in T$. We call a \emph{term} of the type $\tau\in T$ a constant or a variable of that type. We call an \emph{atom} an expression of the form $p(t_1,\ldots,t_n)$, where $n>0$, $p\in P$ is a predicate of the type $\tau_1\times\ldots\times\tau_n$, and each $t_i$, $1\leq i \leq n$ is a term of the type $\tau_i$. We call a \emph{literal} an atom or its negation.

A \emph{rule} is a Horn clause of the form $A\leftarrow L_1 \wedge \ldots \wedge L_n$ $(n \ge 0)$, where the \emph{head} of the rule $A$ is an atom and each of $B_1,\ldots,B_n$ is a literal. If $n=0$ and all arguments of $A$ are constants then we call such rule a fact. We call a \emph{definition} of the predicate $p \in P$ the set of all rules in the network model that use $p$ in their head.

We assume that the signature contains
\begin{enumerate*}[label=(\roman*)]
  \item types $\type{bits16}$ and $\type{bits32}$;
  \item $2^{16}$ constants of the type $\type{bits16}$;
  \item $2^{32}$ constants of the type $\type{bits32}$;
  \item predicates $\pred{bits16}_<$, $\pred{bits16}_\le$, $\pred{bits16}_{+1}$, $\pred{bits16}_{-1}$ of the type $\type{bits16} \times \type{bits16}$ with a special semantics \EK{Careful! $\pred{bits16}_{+1}$ and $\pred{bits16}_{-1}$ are not total functions, mention that!}; and
  \item predicate $\pred{bits32}_\wedge$ or the type $\type{bits32}\times\type{bits32}\times\type{bits32}$ with a special semantics.
\end{enumerate*}
$\type{bits16}$ and $\type{bits32}$ represent the types of 16-bit and 32-bit vectors. The semantics of the predicates is that of the correspondent operations over bit vectors defined in the standard way.

We assume that for each type $\tau\in T$ the signature contains the equality predicate $\pred{=}_\tau$ of the type $\tau\times\tau$ and the network model contains the rule $\pred{=}_\tau(X,X)$.

The specification part of the model contains types, constants, predicates and rules that describe the semantics of the networking components used in a network. For example, the specification defines the semantics of SSH tunneling. One ENI can SSH tunnel to another ENI iff it can either connect to it over SSH directly, or through a chain of one or more intermediate ENIs. In order to express this concept, the specification contains predicates $\pred{canSshTunnel}$ and $\pred{canSsh}$, each of the type $\type{eni}\times\type{eni}$, and the two following rules.
\begin{align*}
\pred{canSshTunnel}(\mathit{Eni}_1,\mathit{Eni}_2)\leftarrow\:&\pred{canSsh}(\mathit{Eni}_1,\mathit{Eni}_2). \\
\pred{canSshTunnel}(\mathit{Eni}_1,\mathit{Eni}_2)\leftarrow\:&\pred{canSshTunnel}(\mathit{Eni}_1,\mathit{Eni}_3)\\
\wedge\:&\pred{canSshTunnel}(\mathit{Eni}_3,\mathit{Eni}_2).
\end{align*}
% can-ssh-tunnel-enis: eni * eni
% -: can-ssh-tunnel-enis Eni1 Eni2
% <- can-ssh-enis Eni1 Eni2.
% -: can-ssh-tunnel-enis Eni1 Eni2
% <- can-ssh-tunnel-enis Eni1 Eni3
% <- can-ssh-tunnel-enis Eni3 Eni2.

The specification of Amazon~VPC networks that we used in this work consists of approximately 50 types, 200 predicates, and over 240 rules.

The snapshot part of the model contains constants and facts that describe the configuration of the networking components in a given network. For example, the snapshot of a network with a single node \verb'i-abcd1234' in a single subnet ``Web'' consists of the constants $\const{node}_\text{abcd1234}$ and $\const{subnet}_\text{Web}$, and the fact $\pred{nodeHasSubnet}(\const{node}_\text{abcd1234},\const{subnet}_\text{Web}).$

\EK{Mention how large network snapshots get?}

\subsection{Network Questions}
\label{sect:aws/reachability/properties}

We express network questions as formulas of many-sorted first-order logic with the standard logical connectives $\vee$, $\wedge$, $\Rightarrow$, $\Leftrightarrow$, $\oplus$, and equality. These formulas only use types, constants, and predicates from the signature of the network model. The formulas do not use any function symbols. We allow interpretation of these formulas to use empty domains and otherwise assume the standard semantics of many-sorted first-order logic.

We express boolean questions as closed formulas, that is, formulas in which all variables are bound by a quantifier. Conversely, we express list questions as formulas with free variables. The answer to a boolean question is true iff its correspondent formula is valid. The answer to a list question is the set of substitutions of variable with constants that satisfy its correspondent formula.

The boolean question in Example~\ref{prop:bool-property} is expressed as the following formula.
\begin{equation}\label{eq:bool-property}
\begin{aligned}
&(\forall w:\type{instance})(\forall d:\type{instance})\\
&\quad(\pred{instanceHasSubnet}(w, \const{subnet}_\text{Web})\:\wedge\:\\
&\quad\,\,\,\pred{instanceHasSubnet}(d, \const{subnet}_\text{Database}) \Rightarrow~\\
&\quad\,\,\,\quad\pred{instanceCanConnectToInstance}(w,d))
\end{aligned}
\end{equation}
% true: all W D: (atom/instance-subnet(W, subnet/web) &&
% atom/instance-subnet(D, subnet/database)) =>
% instance-can-connect-to-instance(W, D).
%In this formula predicates $\pred{instanceHasSubnet}$ and $\pred{instanceCanConnectToInstance}$, and constants $\const{subnet}_\text{Web}$ and $\const{subnet}_\text{Database}$ are part of the signature of the network model~--- the predicate are available in the specification, and the constants are available in the snapshot.

% \EK{We illustrate this difference with the following property.
% \[
% (\forall \mathit{eni}:\type{eni})(\pred{eniOk(\mathit{eni})\vee\neg\pred{eniOk}(\mathit{eni})})
% \]
% % all Eni: (eni-ok(Eni) || !eni-ok(Eni))
% If this query was a formula in first-order logic, it would be a tautology. However, we interpret the property as true iff there exists at least one ENI in the network, that is, if the $\type{eni}$ type is inhabited by at least one value.}

The list questions in Example~\ref{prop:list-property} is expressed as the following formula with the free variables $i$ of the type $\type{instance}$ and $e$ of the type $\type{eni}$. 
\begin{equation}\label{eq:list-property}
\begin{aligned}
&\pred{instanceHasEni}(i,e)\:\wedge~\\
&\begin{aligned}
   \pred{reachablePublicTcpUdp}(&\const{dir}_\text{ingress}, \const{proto}_6, e, \const{port}_{22},\\
                                &\const{publicIp}_\text{8:8:8:8}, \const{port}_\text{40000})
 \end{aligned}
\end{aligned}
\end{equation}
% list: instance-has-eni(Instance, Eni) &&
%         reachable-public-tcp-udp(dir/ingress, proto/6,
%                                          Eni, port/22,
%                                          public-ip/8-8-8-8, port/40000).

All predicates and constants used in Formulas~\ref{eq:bool-property} and \ref{eq:list-property} are part of the signature of the network model. Constants $\const{subnet}_\text{Web}$ and $\const{subnet}_\text{Database}$ are part of the network snapshot, and all other predicates and constants are part of the network specification.

% %-------------------------------------------------------------------------------
% \section{Checking Properties with \Datalog}
% \label{sect:aws/datalog}
% \input{aws/datalog}

%-------------------------------------------------------------------------------
\section{Checking Properties with Theorem Provers}
\label{sect:aws/fol-provers}
% The continuous advances in automated reasoning have made theorem provers into powerful tools capable of efficiently solving problems coming from real world domains. %\EK{FMB might be just as efficient as datalog search, and saturation-based proof search might be more efficient.} 

We translate network models and network questions to problems in first-order logic. We solve these problems using finite model builders and saturation-based theorem provers. We use these two types of provers to leverage the strengths of both of them, which we summarize below.

Finite model builders are commonly implemented in SMT (Satisfiability Modulo Theories) solvers for first-order logic such as Z3~\cite{Z3} or CVC4~\cite{CVC4}. SMT solvers reason in the ground subset of first-order logic with theories using the DPLL algorithm~\cite{davis1960computing} combined with decision procedures for theories. SMT solvers handle quantifiers using heuristic instantiation techniques such as E-matching~\cite{DBLP:journals/jacm/DetlefsNS05,DBLP:conf/cade/MouraB07} and model-based quantifier instantiation~\cite{DBLP:journals/jacm/DetlefsNS05,DBLP:conf/cade/MouraB07}. Finite model builders are designed to efficiently solve satisfiable problems. Given an unsatisfiable problem, finite model builders might detect that the problem cannot have infinite models and in such case report unsatisfiability.

Saturation-based theorem provers such as \eprover\cite{E13}, \spass\cite{Spass} or \vampire\cite{Vampire13} construct proofs of unsatisfiability of first-order problems. To that end, they first convert the input problem into a set of first-order clauses and then try to derive contradiction by applying inference rules such as binary resolution~\cite{Ganzinger01} and superposition~\cite{NieuwenhuisRubio:HandbookAR:paramodulation:2001} to these clauses. \EK{Mention orderings and redundancy elimination.} Saturation-based provers handle theories by adding incomplete first-order theory axioms to the set of clauses and by using specialized inference rules. In addition to that, the \vampire theorem prover implements the AVATAR modulo theories~\cite{DBLP:conf/gcai/RegerB0V16} architecture that relies on an SMT solver for theory-consistent reasoning in the ground subset of the problem. Saturation-based provers are designed to efficiently solve unsatisfiable problems and build proofs of unsatisfiability. Given a satisfiable problem, saturation-based provers can in rare cases report satisfiability and output the saturated set of clauses. However, it is usually not possible to reconstruct a model from this set.

We translate
\begin{enumerate*}[label=(\roman*)]
  \item each boolean question to a first-order problem that is unsatisfiable iff the answer to the question is true; and
  \item each list question to a first-order problem that only has finite models, each corresponding to an answer to the question. \EK{Explain why the translated formulas only have finite models.}
\end{enumerate*}
Table~\ref{fig:fol-answering-questions} summarizes how we interpret a solution found by a theorem prover as the answer to the network question. Saturation-based theorem provers generally cannot answer list questions except for the degenerate case when the answer is empty. With this exception, both types of provers are able to answer both types of network questions. 

\begin{table}
  \center
  \begin{tabular}{lll}
    \hline
    Output of a theorem prover & Boolean question & List question \\
    \hline
    Saturation found unsat & \texttt{true}  & empty list \\
    Saturation found sat   & \texttt{false} & error \\
    FMB found unsat        & \texttt{true}  & empty list \\
    FMB found a model      & \texttt{false} & list of answers \\
  \end{tabular}
  \caption{Solutions found by saturation-based theorem provers and finite model builders (FMB) interpreted as answers to network questions.}
  \label{fig:fol-answering-questions}
\end{table}

%Informally speaking, finite model builders can efficiently answer list questions and saturation-based provers can efficiently answer boolean questions. To complement the performance of a finite model builder and a saturation-based prover, we run both of them in parallel on each first-order problem and record the result of the fastest successful run.

We run a finite model builder and a saturation-based prover in parallel on each problem and record the result of the fastest successful run. We expect that in most cases
\begin{enumerate*}[label=(\roman*)]
  \item a boolean question is answered with \verb'true' by the saturation-based prover and with \verb'false' by the finite model builder; and
  \item a list question is answered with the empty list by the saturation-based prover and with a non-empty list by the finite model builder.
\end{enumerate*}

In this work we used the \vampire theorem prover both as a saturation-based theorem prover and a finite model builder. In addition to its default saturation mode \vampire implements a MACE-style~\cite{mccune1994davis} finite model builder for many-sorted first-order logic~\cite{VampireFMB}. Our translation produces problems expressed in a logic supported by \vampire, namely many-sorted first-order logic with equality, extended with the theory of linear integer arithmetic, the theory of arrays~\cite{VampireAndFOOL}, and the theory of tuples~\cite{KKV18}. %We wrote the problems in the TPTP language~\cite{TPTP}.

Our problems use the first-order formula $\phi$ that expresses the network question and first-order axioms $A_1,\ldots,A_n$ that we translate from the network model. We translate each boolean question to a problem of the form $A_1\wedge\ldots\wedge A_n \Rightarrow \neg\phi$ and each list question to a problem of the form $A_1\wedge\ldots\wedge A_n \wedge (\forall \bar{z})(q(\bar{z})\Leftrightarrow \phi) \Rightarrow (\forall \bar{z})q(\bar{z}),$ where $q$ is a fresh predicate symbol, and $\bar{z}$ are free variables of $\phi$. We reconstruct the answer to a list question from the model of the $q$ predicate~--- each substitution of $\bar{z}$ that satisfies $q$ is an answer to the question.


\section{Network Reachibility as First-Order Problem}\label{sect:aws/fol}
Our translation consists of translation of types and constants, predicate definitions, and theories. We translate types and constants (Section~\ref{sect:aws/fol/types}), and predicate definitions (Section~\ref{sect:aws/fol/predicates}) using Clark completion~\cite{DBLP:conf/adbt/Clark77}. Vampire does not support the theory of bit vectors, therefore we had to craft specialised translations for them using the theories that Vampire support (Section~\ref{sect:aws/fol/theories}).

\subsection{Types and Constants}\label{sect:aws/fol/types}
%Each type in the specification describes a finite domain. Each element in that domain is a constant, explicitly defined in the specification. We translate each type definition to first-order logic by introducing a sort, constants of this sort, and the axiom of the finite domain.

Let $\tau$ be a type and $c_1,\ldots,c_n$ ($n\ge0$) be constants of this type. If $n>0$ then we introduce a sort $\tau$, constants $c_1,\ldots,c_n$ of this sort and add the domain closure axiom of the form $(\forall x:\tau)(x=c_1 \vee\ldots\vee x=c_n)$ and the distinct constants axiom of the form of a conjunction of literals $c_i\not=c_j$ for all $1\le i\le n$, $1\le j\le n$ and $i\not=j$. If $n=0$ then we do not introduce any sorts or constants and in our translation of predicate definitions replace each subformula of the form $(\forall x:\tau)\varphi$ with logical truth and each subformula of the form $(\exists x:\tau)\varphi$ with logical falsum.

For example, the signature contains the type $\type{dir}$ and two constants $\const{dir}_\text{ingress}$ and $\const{dir}_\text{egress}$ of this type. $\type{dir}$ represents the direction of a network package. We translate this type to first-order logic as a sort $\mathit{dir}$, two constants $\mathit{ingress}$ and $\mathit{egress}$ of this sort, and axioms $(\forall x:\mathit{dir})(x=\mathit{ingress}\vee x=\mathit{egress})$ and $\mathit{ingress}\neq\mathit{egress}$.

% dir: type.
% dir/ingress: dir.
% dir/egress: dir.

\subsection{Predicate Definitions}\label{sect:aws/fol/predicates}
%The definitions of predicates in the specification assume the closed world interpretation. It means that a predicate is satisfied iff at least one of its rules is satisfied. To capture the definition in first-order logic we translate a predicate definition using logical equivalence.

% as a predicate symbol $P:\tau_1\times\ldots\times\tau_n$

Let predicate $p$ of the type $\tau_1\times\ldots\times\tau_n$ be defined using $k\ge0$ rules. Let $x_1:\tau_1,\ldots,x_n:\tau_n$ be fresh variables. If $k=0$ then we translate the definition of $p$ to the axiom $$(\forall x_1:\tau_1)\ldots(\forall x_n:\tau_n)(\neg p(x_1,\ldots,x_n)).$$ If $k>0$ then we translate the definition of $p$ to the axiom $$(\forall x_1:\tau_1)\ldots(\forall x_n:\tau_n)(p(x_1,\ldots,x_n)\Leftrightarrow R_1\vee\ldots\vee R_k),$$ where each of the formulas $R_1,\ldots,R_k$ are translations of each of the $k$ rules, respectively.

Let a rule be of the form $$p(t_1,\ldots,t_n)\leftarrow L_1\wedge\ldots\wedge L_m, \quad(m\ge0)$$ where $t_1:\tau_1,\ldots,t_n:\tau_n$ are terms. Let $y_1:\sigma_1,\ldots,y_l:\sigma_l$ be variables that occur in either of $L_1,\ldots,L_m$ but not in $p(t_1,\ldots,t_n)$. If $m=0$ then we translate the rule to the formula $x_1=t_1\wedge\ldots\wedge x_n=t_n.$ If $m>0$ then we translate the rule to the formula
\begin{equation*}
\begin{aligned}
&x_1=t_1\wedge\ldots\wedge x_n=t_n\;\wedge(\exists y_1:\sigma_1)\ldots(\exists y_l:\sigma_l)(L_1\wedge\ldots\wedge L_m).
\end{aligned}
\end{equation*}

%The translation of rules can be refined to only include equalities for non-distinct variables in the head of the rule. The details of such modification are straightforward.

For example, consider the following definition of the predicate $\pred{link}$ of the type $\type{node} \times \type{node}$ that encodes the equivalence relation between two $\type{node}$s. The definition of $\pred{link}$ in not present in the network model, but it is illustrative of our translation.
\begin{equation*}
\begin{aligned}
&\pred{link}(X,X).\\
&\pred{link}(X,Y)\leftarrow\pred{link}(Y,X).\\
&\pred{link}(X,Y)\leftarrow\pred{link}(X,Z)\wedge\pred{link}(Z,Y).
\end{aligned}
\end{equation*}
% link: node * node
% -: link X X.
% -: link X Y
% <- link Y X.
% -: link X Y
% <- link X Z
% <- link Z Y.

We translate the definition of $\pred{link}$ as a predicate symbol $\mathit{Link}: \mathit{node} \times \mathit{node}$ and the axiom
\begin{equation*}
\begin{aligned}
&(\forall x:\mathit{node})(\forall y:\mathit{node})\\
&\quad
 \begin{aligned}
  (\mathit{Link}(x,y)\Leftrightarrow\:&x=y\:\vee\:\\
                                      &Link(y,x)\:\vee\:\\
                                      &(\exists z:\mathit{node})(\mathit{Link}(x,z)\wedge\mathit{Link}(z,y))).
 \end{aligned}
\end{aligned}
\end{equation*}

Our translation ignores definitions of equality predicates and instead uses the standard equality. Our translation ignores (the lack of) definitions of bit vector predicates and instead uses other theories as described in the following section.

\subsection{Theories}
\label{sect:aws/fol/theories}
The network model uses two theories of bit vectors: 16-bit vectors to represent port numbers (as integers between 0 and 65535) and 32-bit vectors to represent IPv4 addresses, subnet masks, and CIDR addresses. %The network model uses 16-bit and 32-bit vector types and corresponding theory predicates, but does not contain definitions for these predicates. Instead, it relies on the implementation of bit vectors in the backend solver.
We translate 16-bit and 32-bit vectors differently.

%In our initial experiments we discovered that the translation of theories crucially affects the performance of \vampire. 

% Section~\ref{sect:fol/theories/optimizations} describes the domain-specific optimizations that we implemented in the translation. They allowed us to simplify the translated problems and increase the performance of \vampire on them.

\paragraph*{16-bit vectors}%\label{sect:fol/theories/16}
The network model uses the type $\type{bits16}$ and predicates $\pred{bits16}_{\le}$ (``less or equal''), $\pred{bits16}_{<}$ (``less than''), $\pred{bits16}_{+1}$ (``successor''), and $\pred{bits16}_{-1}$ (``predecessor''), which are interpreted as correspondent predicates over 16-bit unsigned integers. We translate 16-bit vectors using theory of linear integer arithmetic, supported by Vampire. To this end, we translate
\begin{enumerate*}[label=(\roman*)]
  \item the type $\type{bits16}$ to $\mathbb{Z}$,
  \item each of the 16-bit vector constants to an integer constant, and
  \item each of the 16-bit predicates to their correspondent function symbols in the theory of integer arithmetic.
\end{enumerate*} \EK{We are translating uint16 to $\mathbb{Z}$~--- explain why it is sound.}

\paragraph*{32-bit vectors}%\label{sect:fol/theories/32}
The network model uses the type $\type{bits32}$ and the predicate $\pred{bits32}_\wedge$ (bitwise conjunction). We translate 32-bit vectors using theory of tuples, supported by Vampire. To this end, we translate
\begin{enumerate*}[label=(\roman*)]
  \item the type $\type{bits32}$ to the tuple sort $(\mathit{bool},\ldots,\mathit{bool})$ where $\mathit{bool}$ is repeated 32 times,
  \item each of the 32-bit vector constants to a term $(b_1,\ldots,b_{32})$ of this sort, where each of $b_1,\ldots,b_{32}$ is either $\mathit{true}$ or $\mathit{false}$, and
  \item predicate $\pred{bits32}_\wedge$ to an axiom that defines the bitwise conjunction for boolean tuples.
\end{enumerate*}

\paragraph{Alternative translation for 32-bit vectors}
Our translation of the theory of 32-bit vectors is not the only possible one. For example, one can use the theory of boolean arrays instead. To this end one should translate
\begin{enumerate*}[label=(\roman*)]
  \item the type $\type{bits32}$ to the array sort $\mathit{array}(\mathbb{Z},\mathit{bool})$ and
  \item each of the 32-bit vector constant to a fresh constant $v$ of this sort, defined using the axiom $\mathit{select}(v,1)=b_1\wedge\ldots\wedge\mathit{select}(v, 32)=b_{32},$ where each of $b_1,\ldots,b_{32}$ is either $\mathit{true}$ or $\mathit{false}$.
\end{enumerate*}
Our early experimental results showed that the translation that uses arrays of booleans produces formulas that are harder for \vampire than the translation that uses tuples. We explain it by the fact that in the latter translation a 32-bit vector is represented as a single ground term and not 32 ground literals.

\paragraph{Theory inlining}
Extra optimization: we discovered that operators over 32-bit vectors are only ever used in the following context:
\begin{equation*}
\begin{aligned}
\pred{=}_{bits32}(&\pred{bits32}_{\wedge}(\mathit{CidrBase}_1,\mathit{CidrMask}), \\
                   &\pred{bits32}_{\wedge}(\mathit{CidrBase}_2,\mathit{CidrMask}))
\end{aligned}
\end{equation*}

Solution~-- fuse them together. Instead of translating equality and conjunction
\begin{enumerate}
  \item introduce a predicate $\mathit{EqMask}: \mathit{cidrBase}\times\mathit{cidrBase}\times\mathit{cidrMask}$;
  \item translate each term of the form \texttt{bits/32/eq (bits/32/and x m) (bits/32/and y m)} into $\mathit{EqMask}(x, y, m)$, and
  \item add an axiom for $\mathit{EqMask}$.
\end{enumerate}

Next step~--- notice that many networks only use a limited number of CIDR addresses and ports. We found that we could improve performance by representing a CIDR as finite domain that consists only of CIDRs that are used in the network and pre-compute the results of all operations over CIDRs.

$\pred{PortRangeOverlap}$ of the type $\type{PortRange} \times \type{PortRange}$.

Network only uses port ranges 0--65535, 22--22, 443--443, 5432--5432, 80--80, 80--81 anywhere. 12 facts of the form $$\pred{portRangeOverlap}(\mathit{portRange}_1,\mathit{portRange}_2).$$

To shorten the definition further we can use the fact that $\pred{PortRangeOverlap}$ is a reflexive symmetric binary relation and 0--65535 overlaps with any other port range.
\begin{equation*}
\begin{aligned}
&\pred{portRangeOverlap}(X,X).\\
&\pred{portRangeOverlap}(Y,X)\leftarrow\pred{portRangeOverlap}(X,Y).\\
&\pred{portRangeOverlap}(\const{portRange}_\text{0--65535},\mathit{Y}).\\
&\pred{portRangeOverlap}(\const{portRange}_\text{80--80},\const{portRange}_\text{80--81}).\\
\end{aligned}
\end{equation*}

%-------------------------------------------------------------------------------
\section{Related Work}
\label{sect:aws/related}

SecGuru~--- verification of network connectivity policies at Microsoft Azure using Z3~\cite{jayaraman2014automated}. Basically, they take two sets of ACL rules from firewalls (of the form: connections from this IP range on this port over this protocol are allowed/denied) and calculate their semantic difference using Z3 and ground theory of bit vectors.

SecGuru is a work by Nikolaj Bj\o{}rner et al. Compared to~\cite{jayaraman2014automated} which only talks about ACLs, later they extended it~\cite{DBLP:conf/icdcit/BjornerJ15} with verification of routing tables and Border gateway Protocol (BGP). 

VeriCon~\cite{DBLP:conf/pldi/BallBGIKSSV14}~--- a verification tool for SDN controllers. Basically, program verification for network applications running on firewalls and such, as I understood.

VeriFlow~\cite{Veriflow}~--- checking network-wide invariants in real time, specialised algorithm, verification in the data plane.

ConfigChecker~\cite{ConfigChecker}~--- verification of ACLs, BDD, CRL symbolic model checking, not SDN though.

Anteater~\cite{Anteater}~--- data plane verification using SAT.

CrystalNet~\cite{crystalnet}: Emulation of Large Production Networks

Batfish~\cite{batfish}: \Datalog and SMT

Synthesis of network configurations using \Datalog~\cite{DBLP:conf/cav/El-HassanyTVV17}.

Weidenbach used saturation in \spass to verify security protocols~\cite{Weidenbach99}.

%-------------------------------------------------------------------------------
\section{Conclusions, Discussion and Future Work}
\label{sect:aws/conclusion}

\paragraph{Sensitivity of the translation}
The quality of translation matters a lot. Bad translation --- poor performance. This is a well-known problem in the ATP community. Theorem provers should efficiently implement useful syntactical features and theories beyond vanilla first-order logic. In this work we missed an efficient implementation of the theory of bit vectors in \vampire.

\paragraph{Configurations of theorem provers}
Theorem provers come with gazillions of options, which ones to use?

\paragraph{Unpredictable complexity}
When comparing the performance of \Datalog and theorem provers we saw that the performance time of \Datalog grows accordingly to the complexity of the problem. Performance of theorem provers looks unpredictable due to the nature of the saturation-based proof search. It's cool when a seemingly hard problem has an easy solution, not so cool the other way around. We wonder if a theorem proving community has an answer to it.

\paragraph{Finite domains}
Our problems have to do with large finite domains. Superposition-based theorem provers cannot reason with them efficiently, too bad (cite Weidenbach's work~\cite{HillenbrandWeidenbach13} though).

\paragraph{EPR}
We translate our network models to problems that almost fit the effectively propositional (EPR) fragment of first-order logic, also called the Bernays-Sch\"onfinkel class. These problems do not use function symbols with positive arity, but skolem functions with positive arity might be introduced during clausification. The satisfiability problem for EPR is decidable and there exist efficient tools that deal with this fragment~\cite{DBLP:conf/birthday/Korovin13} \EK{more cites here}. It is possible to translate network models to problems in EPR, for example by instantiating existentially-quantified variables with all elements in the domain of its sort. The obvious drawback of this translation is the blowup of the size of the resulting problem. Whether this blowup can be counteracted by the efficiency of EPR solvers is an interesting question for future work.

\paragraph{Future Work}
We used a specification which is \Datalog-friendly and not necessarily friendly for reasoning in first-order logic~--- only predicates, no functions. It would be interesting to rewrite it in first-order logic. We only took Vampire, but would be interesting to compare other provers, or even use a portfolio of provers instead of just one.

%-------------------------------------------------------------------------------
\section*{Acknowledgments}
\label{sect:aws/acks}
This work has been partially carried out during the first author's visit to Amazon Web Services. In addition, the first author was partially supported by the Wallenberg Academy Fellowship 2014 and the Swedish VR grant D0497701.
