\usepackage{listings}
\lstdefinelanguage{tptp}{
  basicstyle={\ttfamily},
  columns=flexible,
  keywords={tff, type, axiom, hypothesis, conjecture},
  sensitive=true,
  captionpos=b,
}
\lstset{literate=
  {~}{{\textapprox}}1
}
\lstset{language=tptp}
\lstset{breaklines}

\lstdefinelanguage{haskell}{
  basicstyle={\ttfamily},
  columns=flexible,
  morekeywords={if, then, else, where, let, in},
  sensitive=true,
  captionpos=b
}
\lstset{literate=
  {->}{{$\rightarrow\:\:$}}1
}

\lstdefinelanguage{cpp}{
  basicstyle={\ttfamily},
  columns=flexible,
  keywords={public, static, void, do, for, while, int, bool, if, else, break},
  sensitive=true,
  captionpos=b
}

\newcommand{\reserved}[1]{\textbf{\underline{#1}}} % reserved words in algorithms
\newcommand{\ass}{\texttt{:=}}     % assignment operator
\newcommand{\inc}{~~~~\= \+ \kill}    % used in algorithms
\newcommand{\dec}{\- \kill}         % used in algorithms
\newcommand{\semicol}{;}                  % semicolon in algorithms

\newcommand{\INPUT}{\reserved{input}}
\newcommand{\OUTPUT}{\reserved{output}}
\newcommand{\IF}{\reserved{if}}
\newcommand{\VAR}{\reserved{var}}
\newcommand{\CASE}{\reserved{case}}
\newcommand{\OF}{\reserved{of}}
\newcommand{\DO}{\reserved{do}}
\newcommand{\OD}{\reserved{end~do}}
\newcommand{\THEN}{\reserved{then}}
\newcommand{\ELSE}{\reserved{else}}
\newcommand{\WHILE}{\reserved{while}}
\newcommand{\BEGIN}{\reserved{begin}}
\newcommand{\END}{\reserved{end}}
\newcommand{\LET}{\reserved{let}}
\newcommand{\FORALL}{\reserved{forall}}
\newcommand{\ASS}{\texttt{ := }}
\newcommand{\RETURN}{\reserved{return}}
\newcommand{\REPEAT}{\reserved{repeat}}
\newcommand{\LOOP}{\reserved{loop}}

\newcommand{\extTFF}{TFF0\textsuperscript{ext}}
\newcommand{\nofoolVampire}{Vampire$\,\star$}
\newcommand{\oldcnfVampire}{Vampire$\,\star$}

\newcommand{\ite}[3]{\mathtt{if}\;{#1}\;\allowbreak\mathtt{then}\;{#2}\;\allowbreak\mathtt{else}\;{#3}}
\newcommand{\itet}[3]{\mathrm{ite\_t}({#1},\;{#2},\;{#3})}
\newcommand{\ITE}{\texttt{if}-\texttt{then}-\texttt{else}}
\newcommand{\binding}[2]{{#1}\,=\,{#2}}
\newcommand{\letin}[3]{\mathtt{let}\;\binding{#1}{#2}\;\allowbreak\mathtt{in}\;{#3}}
\newcommand{\letinpar}[5]{\mathtt{let}\;\binding{#1}{#2};\;\binding{#3}{#4}\;\mathtt{in}\;{#5}}
\newcommand{\LETIN}{\texttt{let}-\texttt{in}}
\newcommand{\ofsort}[2]{{{#1}:{#2}}}
\newcommand{\set}[2]{{\left\{\,{#1}\;|\;{#2}\,\right\}}}

\newcommand{\builtin}[1]{\mathtt{\${#1}}}
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\bool}{\mathit{bool}}
\newcommand{\fool}{{FOOL}}% how should we call FOL with boolean?
\newcommand{\foolp}{{FOOL+}}

\newcommand{\textapprox}{\raise.17ex\hbox{$\scriptstyle\mathtt{\sim}$}}

% logic
\renewcommand{\implies}{\Rightarrow}
\newcommand{\liff}{\Leftrightarrow}
\newcommand{\lniff}{\not\Leftrightarrow}
%\newcommand{\lor}{\vee}

\newcommand{\eql}{\doteq}
\newcommand{\neql}{\not\doteq}

% overstrike in math
\newcommand\hcancel[1]{\setbox0=\hbox{$#1$}%
\rlap{\raisebox{.45\ht0}{\rule{\wd0}{0.4pt}}}#1}

%
\newcommand{\context}{\eta}

\newcommand{\extension}[1]{{#1}_+}

\newcommand{\intI}{I} % interpretation I

\newcommand{\interpret}[2]{\left\llbracket\,{#1}\,\right\rrbracket_{#2}}
\newcommand{\eval}[2]{\mathrm{eval}_{#2}({#1})}
\newcommand{\replacement}[3]{{#1}_{#2}^{#3}}

\newcommand{\variant}[3]{{#1}_{#2}^{#3}}

\newcommand{\folb}{{FOOL}}% how should we call FOL with boolean?
\newcommand{\toFOL}[1]{\mathit{fol}(#1)}  % translation of syntactially FO to FO

\newcommand{\newcnf}{\textsc{new-cnf}}

% end of definition, theorem, proof etc.
\newcommand{\QEDsymbol}{\text{\ding{111}}}
\newcommand{\QED}{\hfill\QEDsymbol}

% logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\phi}{\varphi}

% newcnf
\newcommand{\possign}{+}
\newcommand{\negsign}{-}
\newcommand{\genlit}[2]{{#1}^{#2}}
\newcommand{\genclause}[2]{{#1}_{#2}}

\newcommand{\sign}{\sigma}
\newcommand{\subst}{\theta}
\newcommand{\emptySubst}{\epsilon}

\newcommand{\GC}{\mathit{D}}

\newcommand{\sk}{\mathit{sk}}

% TPTP true, false and bool
\newcommand{\tptpo}{\lstinline'$o'} %$
\newcommand{\dbool}{\lstinline'$bool'} %$
\newcommand{\dtrue}{\lstinline'$true'} %$
\newcommand{\dfalse}{\lstinline'$false'} %$
\newcommand{\ddtrue}{\lstinline'$$true'}
\newcommand{\ddfalse}{\lstinline'$$false'}

% TPTP ite and let
\newcommand{\dite}{\lstinline'$ite'} %$
\newcommand{\ditet}{\lstinline'$ite_t'} %$
\newcommand{\ditef}{\lstinline'$ite_f'} %$

\newcommand{\dlet}{\lstinline'$let'} %$
\newcommand{\dlettt}{\lstinline'$let_tt'} %$
\newcommand{\dlettf}{\lstinline'$let_tf'} %$
\newcommand{\dletft}{\lstinline'$let_ft'} %$
\newcommand{\dletff}{\lstinline'$let_ff'} %$

\newcommand{\dint}{\lstinline'$int'} %$
\newcommand{\dgreatereq}{\lstinline'$greatereq'} %$
\newcommand{\dsum}{\lstinline'$sum'} %$

\newcommand{\di}{\lstinline'$i'} %$

\newcommand{\arrayt}{\mathit{array}}
%\newcommand{\select}[2]{{#1}[{#2}]}
%\newcommand{\selectf}{\select{\cdot\,}{\,\cdot\,}}
\newcommand{\select}[2]{\mathit{select}({#1},{#2})}
\newcommand{\selectf}{\mathit{select}}
%\newcommand{\store}[3]{{#1}\langle{#2}\lhd{#3}\rangle}
%\newcommand{\storef}{\store{\cdot\,}{\,\cdot}{\cdot\,}}
\newcommand{\store}[3]{\mathit{store}({#1},{#2},{#3})}
\newcommand{\storef}{\mathit{store}}

\newcommand{\darray}[2]{\darraySymb\lstinline'('{#1}\lstinline','{#2}\lstinline')'}
\newcommand{\darraySymb}{\lstinline'$array'} %$
\newcommand{\dselect}{\lstinline'$select'} %$
\newcommand{\dstore}{\lstinline'$store'} %$
\newcommand{\darrayone}{\lstinline'$array1'} %$
\newcommand{\dselectone}{\lstinline'$select1'} %$
\newcommand{\dstoreone}{\lstinline'$store1'} %$
\newcommand{\darraytwo}{\lstinline'$array2'} %$
\newcommand{\dselecttwo}{\lstinline'$select2'} %$
\newcommand{\dstoretwo}{\lstinline'$store2'} %$

% the rest
\newcommand{\Z}{\mathds{Z}}
\newcommand{\R}{\mathds{R}}
