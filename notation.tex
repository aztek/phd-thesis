\usepackage{color}
\definecolor{lstgrey}{rgb}{0.96,0.96,0.96}
\usepackage{listings}

\lstset{
  basicstyle=\ttfamily,
  columns=flexible,
  keepspaces=true,
  backgroundcolor=\color{lstgrey},
  breaklines=false,
  sensitive=true,
  captionpos=b,
  frame=single,
  framerule=0pt,
  framesep=2pt,
  xleftmargin=3pt,
  xrightmargin=3pt,
  resetmargins=true,
  rulecolor=\color{lstgrey}
  % frameround=tttt,
%  literate={~}{{\textapprox}}1
}

\usepackage{xpatch}
\usepackage{realboxes}
\makeatletter
\xpretocmd\lstinline
  {%
   \bgroup\fboxsep=1.5pt
   \Colorbox{lstgrey}\bgroup\vphantom{\ttfamily\char`\\y}%
   \appto\lst@DeInit{\egroup\egroup}%
  }{}{}
\makeatother

% \makeatletter
% \xpretocmd\lstinline{\Colorbox{lstgrey}\bgroup\appto\lst@DeInit{\egroup}}{}{}
% \makeatother


\lstdefinelanguage{tptp}{
  keywords={tff, thf, fof, cnf, type, axiom, hypothesis, conjecture}
}

\lstdefinelanguage{cpp}{
  keywords={public, static, void, do, for, while, int, bool, if, then, else, break, assert, let, in}
}

\lstdefinelanguage{appendixcpp}{
  keywords={public, static, void, do, for, while, int, bool, if, else, break, assert}
}

\lstdefinelanguage{bnf}{}

\newcommand{\reserved}[1]{\textbf{\underline{#1}}} % reserved words in algorithms
\newcommand{\ass}{\texttt{:=}}     % assignment operator
\newcommand{\inc}{~~~~\= \+ \kill}    % used in algorithms
\newcommand{\dec}{\- \kill}         % used in algorithms
\newcommand{\semicol}{;}                  % semicolon in algorithms

\newcommand{\INPUT}{\reserved{input}}
\newcommand{\OUTPUT}{\reserved{output}}
\newcommand{\IF}{\reserved{if}}
\newcommand{\VAR}{\reserved{var}}
\newcommand{\CASE}{\reserved{case}}
\newcommand{\OF}{\reserved{of}}
\newcommand{\DO}{\reserved{do}}
\newcommand{\OD}{\reserved{end~do}}
\newcommand{\THEN}{\reserved{then}}
\newcommand{\ELSE}{\reserved{else}}
\newcommand{\WHILE}{\reserved{while}}
\newcommand{\BEGIN}{\reserved{begin}}
\newcommand{\END}{\reserved{end}}
\newcommand{\LET}{\reserved{let}}
\newcommand{\FORALL}{\reserved{forall}}
\newcommand{\ASS}{\texttt{ := }}
\newcommand{\RETURN}{\reserved{return}}
\newcommand{\REPEAT}{\reserved{repeat}}
\newcommand{\LOOP}{\reserved{loop}}

\newcommand{\extTFF}{TFF0\textsuperscript{ext}}
\newcommand{\nofoolVampire}{Vampire$\,\star$}
\newcommand{\oldcnfVampire}{Vampire$\,\star$}

\newcommand{\ite}[3]{\mathtt{if}\;{#1}\;\allowbreak\mathtt{then}\;{#2}\;\allowbreak\mathtt{else}\;{#3}}
\newcommand{\itet}[3]{\mathrm{ite\_t}({#1},\;{#2},\;{#3})}
\newcommand{\ITE}{\texttt{if}-\texttt{then}-\texttt{else}}
\newcommand{\binding}[2]{{#1}={#2}}
\newcommand{\letin}[3]{\mathtt{let}\;\binding{#1}{#2}\;\allowbreak\mathtt{in}\;{#3}}
\newcommand{\letindef}[2]{\mathtt{let}\;{#1}\;\allowbreak\mathtt{in}\;{#2}}
\newcommand{\letinpar}[5]{\mathtt{let}\;\binding{#1}{#2};\;\binding{#3}{#4}\;\mathtt{in}\;{#5}}
\newcommand{\LETIN}{\texttt{let}-\texttt{in}}
\newcommand{\ofsort}[2]{{{#1}:{#2}}}
\newcommand{\set}[2]{{\left\{\,{#1}\;|\;{#2}\,\right\}}}

\newcommand{\builtin}[1]{\mathtt{\${#1}}}
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\bool}{\mathit{bool}}
\newcommand{\fool}{{FOOL}}% how should we call FOL with boolean?
\newcommand{\foolp}{{FOOL+}}

% logic
\renewcommand{\implies}{\Rightarrow}
\newcommand{\liff}{\Leftrightarrow}
\newcommand{\lniff}{\not\Leftrightarrow}
%\newcommand{\lor}{\vee}

\newcommand{\eql}{\doteq}
\newcommand{\neql}{\not\doteq}

% overstrike in math
\newcommand\hcancel[1]{\setbox0=\hbox{$#1$}%
\rlap{\raisebox{.45\ht0}{\rule{\wd0}{0.4pt}}}#1}

%
\newcommand{\context}{\eta}

\newcommand{\extension}[1]{{#1}_+}

\newcommand{\intI}{I} % interpretation I

\newcommand{\interpret}[2]{\left\llbracket\,{#1}\,\right\rrbracket_{#2}}
\newcommand{\eval}[2]{\mathrm{eval}_{#2}({#1})}
\newcommand{\replacement}[3]{{#1}_{#2}^{#3}}

\newcommand{\variant}[3]{{#1}_{#2}^{#3}}

\newcommand{\folb}{{FOOL}}% how should we call FOL with boolean?
\newcommand{\toFOL}[1]{\mathit{fol}(#1)}  % translation of syntactially FO to FO

% end of definition, theorem, proof etc.
%\newcommand{\QEDsymbol}{\text{\ding{111}}}
\newcommand{\QEDsymbol}{\qed}
\newcommand{\QED}{\hfill\QEDsymbol}

% logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\phi}{\varphi}

% newcnf
\newcommand{\possign}{\mathtt{t}}
\newcommand{\negsign}{\mathtt{f}}
\newcommand{\genlit}[2]{{#1}^{#2}}
\newcommand{\genclause}[2]{{#1}_{#2}}

\newcommand{\sign}{\star}
\newcommand{\subst}{\theta}
\newcommand{\emptySubst}{\epsilon}

\newcommand{\formName}{\mathtt{form}}
\newcommand{\form}[1]{\formName({#1})}

\newcommand{\config}[2]{#1}

\newcommand{\GC}{\mathit{C}}

\newcommand{\sk}{\mathit{sk}}

% TPTP true, false and bool
\newcommand{\tptpo}{\lstinline'$o'} %$
\newcommand{\dbool}{\lstinline'$bool'} %$
\newcommand{\dtrue}{\lstinline'$true'} %$
\newcommand{\dfalse}{\lstinline'$false'} %$
\newcommand{\ddtrue}{\lstinline'$$true'}
\newcommand{\ddfalse}{\lstinline'$$false'}

% TPTP ite and let
\newcommand{\dite}{\lstinline'$ite'} %$
\newcommand{\ditet}{\lstinline'$ite_t'} %$
\newcommand{\ditef}{\lstinline'$ite_f'} %$

\newcommand{\dlet}{\lstinline'$let'} %$
\newcommand{\dlettt}{\lstinline'$let_tt'} %$
\newcommand{\dlettf}{\lstinline'$let_tf'} %$
\newcommand{\dletft}{\lstinline'$let_ft'} %$
\newcommand{\dletff}{\lstinline'$let_ff'} %$

\newcommand{\dint}{\lstinline'$int'} %$
\newcommand{\dgreatereq}{\lstinline'$greatereq'} %$
\newcommand{\dsum}{\lstinline'$sum'} %$

\newcommand{\di}{\lstinline'$i'} %$

\newcommand{\arrayt}{\mathit{array}}
%\newcommand{\select}[2]{{#1}[{#2}]}
%\newcommand{\selectf}{\select{\cdot\,}{\,\cdot\,}}
\newcommand{\select}[2]{\mathit{select}({#1},\allowbreak{#2})}
\newcommand{\selectf}{\mathit{select}}
%\newcommand{\store}[3]{{#1}\langle{#2}\lhd{#3}\rangle}
%\newcommand{\storef}{\store{\cdot\,}{\,\cdot}{\cdot\,}}
\newcommand{\store}[3]{\mathit{store}({#1},\allowbreak{#2},\allowbreak{#3})}
\newcommand{\storef}{\mathit{store}}

\newcommand{\darray}[2]{\darraySymb\lstinline'('{#1}\lstinline','{#2}\lstinline')'}
\newcommand{\darraySymb}{\lstinline'$array'} %$
\newcommand{\dselect}{\lstinline'$select'} %$
\newcommand{\dstore}{\lstinline'$store'} %$
\newcommand{\darrayone}{\lstinline'$array1'} %$
\newcommand{\dselectone}{\lstinline'$select1'} %$
\newcommand{\dstoreone}{\lstinline'$store1'} %$
\newcommand{\darraytwo}{\lstinline'$array2'} %$
\newcommand{\dselecttwo}{\lstinline'$select2'} %$
\newcommand{\dstoretwo}{\lstinline'$store2'} %$

\newcommand{\skolem}{skolem}

% the rest
\newcommand{\Z}{\mathds{Z}}
\newcommand{\R}{\mathds{R}}

% tuples
\newcommand{\tuple}[1]{({#1})}

\newcommand{\newcnf}{\textsc{VCNF}}
\newcommand{\nfcnf}{$\text{\textsc{VCNF}}_{\text{\textsc{FOOL}}}$}
\newcommand{\oldcnf}{\textsc{FOOL2FOL}}

\newcommand{\integer}{\mathit{int}}
\newcommand{\emptyStatement}{\mathtt{skip}}
\newcommand{\assigns}[2]{{#1}\coloneqq{#2}}
\newcommand{\seq}[2]{{#1}\,;{#2}}
\newcommand{\translateT}{\mathcal{T}}
\newcommand{\translate}[1]{\translateT({#1})}
\newcommand{\tuplifyT}{\mathcal{N}}
\newcommand{\tuplifyRel}[1]{\tuplifyT({#1})}
\newcommand{\tuplify}[2]{\tuplifyRel{{#1}}({#2})}
\newcommand{\updates}[1]{\mathrm{updates}({#1})}

\newcommand{\ifthen}[2]{\mathtt{if}\;{#1}\;\allowbreak\mathtt{then}\;{#2}}

\newcommand{\while}[2]{\mathtt{while}\;{#1}\;\mathtt{do}\;{#2}}

\newcommand{\ttrue}{\mathtt{true}}
\newcommand{\tfalse}{\mathtt{false}}

\newcommand{\letinnl}[3]{\begin{aligned}[t]&\mathtt{let}\;\binding{#1}{#2}\;\mathtt{in}\\[-0.2em]&\quad{#3}\end{aligned}}
\newcommand{\letnl}[3]{\begin{aligned}[t]\mathtt{let}\;&\binding{#1}{#2}\\[-0.2em]\mathtt{in}\;&{#3}\end{aligned}}

\newcommand{\letinparnl}[5]{\begin{aligned}[t]\mathtt{let}\;&\binding{#1}{#2};\;\binding{#3}{#4}\\\mathtt{in}\;&{#5}\end{aligned}}

\newcommand{\itenll}[3]{\begin{aligned}[t]&\mathtt{if}\;{#1}\\[-0.2em]&\mathtt{then}\;{#2}\\[-0.2em]&\mathtt{else}\;{#3}\end{aligned}}

\newcommand{\itenl}[3]{\begin{aligned}[t]\mathtt{if}\;{#1}\;&\mathtt{then}\;{#2}\\&\mathtt{else}\;{#3}\end{aligned}}


\newcommand{\interp}[1]{\left\llbracket\,{#1}\,\right\rrbracket}

\newcommand{\expr}{\mathit{e}}
\newcommand{\stmt}{\mathit{s}}
\newcommand{\State}{\mathit{st}}

\newcommand{\hoare}[3]{\{{#1}\}\,{#2}\,\{{#3}\}}

\newcommand{\pint}{\mathtt{int}}
\newcommand{\pbool}{\mathtt{bool}}
\newcommand{\parray}{\mathtt{array}}