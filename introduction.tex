Computer mathematics studies processing of mathematical knowledge with a computer. It explores questions of how to represent mathematical problems and their proofs in a computer, how to check correctness of proofs by a computer and even how to construct proofs automatically using a computer. The latter is the domain of automated theorem proving. It is one of the central and hardest areas of computer mathematics and artificial intelligence. Automated methods of proving theorems precede the existence of computers (see e.g. \cite{bundy1999survey,davis2001early,harrison2007short} for a historical survey).

In order to be represented in a computer, a mathematical problem must be expressed in a language of some formal logic. Among the logics used for this purpose are propositional, first-order and higher-order logic, intuitionistic logic, modal, temporal, many-values logic and others.

Algorithms of automated theorem proving are implemented in computer programs called theorem provers. A theorem prover takes a logical conjecture as input and tries to either construct its proof or demonstrate that the conjecture is invalid. Theorem provers can be classified by the logic they support. Propositional, first-order and higher-order logic are among the logics that received the most attention in automated theorem proving. Reasoning in propositional logic, i.e. solving the problem of propositional satisfiability (SAT), is implemented in \emph{SAT solvers}, such as Lingeling~\cite{Lingeling} and Minisat~\cite{Minisat}. Solving the problem of satisfiability modulo theory (SMT) is implemented in \emph{SMT solvers}, such as Z3~\cite{Z3} and CVC4~\cite{CVC4}. Reasoning is first-order logic is implemented in \emph{first-order theorem provers}, such as Vampire~\cite{Vampire13}, E~\cite{E13} and iProver~\cite{iProver}. Reasoning in higher-order logic is implemented in \emph{higher-order theorem provers}, such as Satallax~\cite{Satallax} and Leo-II~\cite{LeoII}.

Generally speaking, the more expressive a logic is, the harder it is to reason in it. For example, satisfiability of a propositional problem can always be established, albeit possibly at a high computational cost. Modern SAT solvers implement elaborate algorithms that guarantee good performance characteristics in the average case. In contrast, satisfiability or unsatisfiability of a first-order problem cannot be in general established by any algorithm. Implementors of first-order provers face the challenge of making the provers succeed on as many real world problems as possible.

Theorem provers are used for software and hardware verification, information management, combinatorial reasoning, and more. They are also the most powerful mean of proof automation in interactive proof assistants. In most applications, the theorem checked by a theorem prover is generated by an external software tool and not given by a human. %Many verification tools integrate theorem provers and supply them with machine-generated theorems.

This thesis contributes to the area of automated theorem proving by presenting an extension of first-order logic that is useful for applications and can be supported by first-order theorem provers. This chapter describes the background of the thesis and is structured as follows. Section~\ref{sect:intro:fol} gives an introduction to automated theorem proving in first-order logic. Sections \ref{sect:intro:analysis} and \ref{sect:intro:itp} describe two important applications of first-order provers, automation for program verification and interactive proof assistants. Section~\ref{sect:intro:problem} states the problem addressed in the thesis, and finally Section~\ref{sect:intro:contributions} summarises the contributions of the thesis.


\section[Automated Theorem Proving in First-Order Logic]{Automated Theorem Proving in\\First-Order Logic}\label{sect:intro:fol}
The problem of establishing validity of a first-order problem automatically can be traced back to Hilbert. In 1928 he posed a question, traditionally referred to as \emph{Entscheidungsproblem}\iffalse(German for ``decision problem'')\fi, stated as follows. Is there an algorithm that takes as input a statement in first-order logic and terminates with ``Yes'' or ``No'' according to whether or not the statement is valid?

This question has been answered negatively in 1936 independently by Church~\cite{church1936unsolvable} and Turing~\cite{turing1936computable}. Their proofs rely on the famous G\"{o}del's incompleteness theorem\iffalse~\cite{godel1931formal} (for an English translation see e.g. \cite[pp. 4--38]{davis1965undecidable})\fi. G\"{o}del's result entails that the problem of provability in first-order logic is not decidable, but \emph{semi-decidable}. Informally, it means that if a logical sentence of the form ``$\varphi$ implies $\psi$'' is valid, that can be established by enumerating all finite derivations in the logical system. A derivation between $\varphi$ and $\psi$ will necessarily be found in that enumeration. On the other hand, if the sentence is invalid, there is no algorithm that could in general demonstrate that.

The problem of validity of a problem in first-order logic is often formulated in terms of unsatisfiability. Validity of a formula is equivalent to unsatisfiability of its negation. To prove validity of a formula one can derive contradiction from its negation, thus constructing a proof by \emph{refutation}. Conversely, invalidity of a formula is equivalent to satisfiability of its negation. To demonstrate invalidity of a formula one can find a model of its negation. Algorithms that search for satisfiability and unsatisfiability of first-order formulas are usually implemented as separate procedures.

Despite the complexity of automated reasoning in first-order logic, several methods were found to be efficient for finding unsatisfiability for non-trivial problems. Modern state-or-the-art automated theorem provers are based on superposition calculus~\cite{NieuwenhuisRubio:HandbookAR:paramodulation:2001} and its refinements. Finding satisfiability is a much harder problem because a formula might only have infinite models.\iffalse In practice, the search for satisfiability is limited to finite models.\fi

Methods of first-order reasoning usually work not with arbitrary first-order formulas, but with first-order clauses. A first-order formula is in clausal normal form (CNF) if it has the shape $\forall x_1\ldots\forall x_n(C_1\wedge\ldots\wedge C_n)$, where $C_i = L_{i,1}\vee\ldots\vee L_{i,l_i}$ and each $L_{i,j}$ is a literal. An alternative representation of a CNF is a set of first-order clauses that form a disjunction. A first-order clause is an implicitly universally quantified disjunction of positive and negative first-order literals. A CNF translation converts an arbitrary first-order formula to CNF, preserving satisfiability. First-order provers that support formulas in full first-order logic implement such translations as part of their preprocessing of the input.

Superposition-based theorem proving stems from the work of Robinson~\cite{Robinson65} on \emph{resolution calculus}. Resolution calculus establishes unsatisfiability of a set of first-order clauses by systematically and exhaustively applying a set of inference rules which include the resolution inference rule. Resolution calculus is refutationally complete, meaning that a contradiction can be deduced from any unsatisfiable set of clauses. The novelty of Robinson's work was in the usage of \emph{unification} for instantiation of variables. Unification avoids combinatorial explosion of ground instances of quantified formulas that was present e.g. in an earlier algorithm of Davis and Putnam \cite{davis1960computing}\footnote{This algorithm however retained as the prevalent method for establishing propositional satisfiability after a refinement by Logemann and Loveland~\cite{davis1962machine}.}.

Resolution calculus is refined by \emph{superposition calculus}~\cite{BG90, BG94} that employs term orderings for restricting the number of inferences. The basic idea of superposition is to only allow inferences that replace ``big'' terms by ``smaller'' ones, with respect to the given ordering.

%Most of the interesting mathematical problems use equality. Naturally, efficient reasoning with equality is an important research question. The equality relation can be finitely axiomatised in first-order logic. However, resolution with equality axioms was found to generate enormous search spaces and thus be very inefficient. In order to overcome this situation, it was proposed to replace the equality axioms by an extra inference rule, called \emph{paramodulation}~\cite{WRCS67,Robinson1969}. Essentially, paramodulation mechanises the principle of replacing equals by equals. These days, resolution-based automated theorem proving systems consider first-order logic with equality as part of the language and the paramodulation rule istead of the equality axiom system.

%An important ingredient in paramodulation is the use of \emph{term orderings} for restricting the number of inferences. The basic idea of ordered paramodulation is to only perform replacements of ``big'' terms by ``smaller'' ones, with respect to the given ordering. The first instances of ordered paramodulation appeared in Knuth-Bendix completion~\cite{KB83}. Roughly, a completion procedure attempts to transform a given set of equations into an equivalent confluent one. A crucial step of the transformation process is the computation of critical pairs between equations. A critical pair is an equation obtained by \emph{superposition}, the restricted version of paramodulation in which inferences only involve left hand sides of possible rewrite steps, i.e., only the ``big'' terms (w.r.t. the given ordering) are considered. During the completion process equations are simplified by rewriting, and tautologies are removed. \EK{I don't quite undestand this, so it reads a bit vague.} Bachmair and Ganzinger refined these ideas into what got to be known as \emph{superposition calculus}~\cite{BG90, BG94}, that now forms the basis for most first-order theorem provers.

%The performance of a first-order prover significantly depends on the syntactical structure of the problem. 

Most of interesting problems tackled by first-order provers are expressed in first-order logic extended with theories. In order to facilitate superposition reasoning in some theory, it is common to extend superposition calculus with a dedicated inference rule instead of applying standard superposition to an axiomatisation of the theory. For example, instead of axiomatising the equality relation, first-order provers usually extend superposition with the paramodulation rule~\cite{WRCS67,Robinson1969}. In a more recent result~\cite{ATVA14}, Vampire was extended to support the extensionality resolution rule to efficiently reason with the extensionality axiom.

First-order provers are currently evaluated on empirical grounds. Comparison between provers are mostly based on success rates and run times on standard corpora of problems. The main corpus is the Thousands of Problems for Theorem Provers (TPTP) library~\cite{TPTP}. The problems in this corpus are written in a variety of languages, such as FOF for untyped first-order formulas, TFF0~\cite{tff0} for typed monomorphic first-order formulas and TFF1~\cite{tff1} for typed rank-1 polymorphic first-order formulas. The TPTP library is used as a basis for the CASC system competition~\cite{CASC}, organised annually.

%People looking into diffent extensions of superposition calculi by specific inference mechanisms for various theories. Their motivation was always that inference rules dedicated to a particular theory are superior to applying standard superposition to an axiomatization of the theory.

%Automated methods of theorem proving are appealing for mechanically checking problems that are too dull and time-consuming to be checked by humans.


\section[Automation for Program Verification]{Automation for Program Verification}\label{sect:intro:analysis}
Methods of program verification check that a program satisfies its specification. A program specification can be expressed with logical formulas that annotate program statements, capturing their properties. Typical examples of such properties are pre- and post-conditions, loop invariants and Craig interpolants. These program properties are checked using various tools, including theorem provers (see e.g. \cite{Bonacina10} for a detailed overview).

Automated program verification sees compliance with specification as a theorem that can be automatically checked by theorem provers. For that, program statements are first translated to logical formulas that capture the semantics of the statements. Then, a theorem is built with the translated formulas as axioms and program properties as the conjecture. Validity of the theorem is interpreted as that the program statements have their annotated properties.

Theorem provers can be used not just for checking program properties, but also for generating them. Recent approaches in interpolation and loop invariant generation~\cite{McMillan08,fase2009,hoder2012popl} present initial results of using first-order theorem provers for generating quantified program properties. First-order theorem provers can also be used to generate program properties with quantifier alternations~\cite{fase2009}; such properties could not be generated fully automatically by any previously known method.

\section[Automation for Proof Assistants]{Automation for Proof Assistants}\label{sect:intro:itp}
A proof assistant (also called an interactive theorem prover) is a software tool that assists the user in constructing proofs of mathematical problems. Proof assistants use formalisations of mathematics based on higher-order logic (Isabelle/HOL~\cite{Isabelle}), type theory (Coq~\cite{Coq}), set theory (Mizar~\cite{Mizar}) and others.

Many proof assistants enhance the workflow of their users by automatically filling in parts of the user's proof with the help of tactics. Tactics are specialised scripts that run a predefined collection of proof searching strategies. These strategies can be implemented inside the proof assistant itself or rely on third-party automated theorem provers~\cite{Sledgehammer,DBLP:conf/icms/UrbanHV10}.

To automate proof search for a problem using a theorem prover, a proof assistant first translates the problem into the logic supported by the theorem prover. Since the logics of proof assistants are usually more expressive than the logics of automated provers, the translation can be incomplete. If the theorem prover reports back a proof, the proof assistant uses it to reconstruct a proof in its own logic.


\section{Problem Statement}\label{sect:intro:problem}
Both systems of automated program verification and proof assistants use first-order theorem provers but usually do not natively work with first-order logic. Instead, they translate problems in their respective domains (program properties or formulas in the logic of the proof assistant) to problems in first-order logic. Such translations are not straightforward because of a mismatch between the semantics of first-order logic and that of the domain. They can be very complex and thus error prone.

The performance of a theorem prover on the result of a translation crucially depends on whether the translation introduces formulas potentially making the prover inefficient. Theorem provers, especially first-order ones, are known to be very fragile with respect to the input. Expressing program properties in the ``right'' format therefore requires solid knowledge about how theorem provers work and are implemented~--- something that a user of a prover might not have. 

If a theorem prover natively supports expressions that mirror the semantics of programming language constructs or features of other logics, we solve both above mentioned problems. First, the users do not have to design translations of such constructs. Second, the users do not have to possess a deep knowledge of how the theorem prover works~--- the efficiency becomes the responsibility of the prover itself.

This thesis identifies the following syntactical constructs that are generally not supported by first-order provers: first class boolean sort, \ITE\ expressions and \LETIN\ expressions. These constructs are ubiquitous in problems coming from program verification and interactive theorem provers, yet all of them currently require specialised translations. The problem addressed in this thesis is the extension of the input language and underlying logic of first-order theorem provers with these constructs.

Boolean values in programming languages are used both as conditions in conditional or loop statements, and as boolean flags, passed as arguments to functions. A natural way of translating program statements with booleans into formulas is by translating conditions as formulas, and function arguments as terms. Yet we cannot mix boolean terms and formulas in the same way in first-order logic, unless the boolean sort is first class. Properties expressed in higher-order logic routinely use quantification over the interpreted boolean sort; this is not allowed in first-order logic either. Program statements with conditionals can be directly translated to \ITE\ expressions. Assignments in imperative programs can be translated to a series of nested \LETIN\ expressions. Both of these constructs are actively used by the users of proof assistants to structure their problems. %While SMT solvers integrate \ITE\ and \LETIN\ expressions, first-order provers in general do not support them.

\section{Contributions of the Thesis}\label{sect:intro:contributions}
This thesis presents an extension of first-order logic that contains the aforementioned missing features of first-order theorem provers and explores how reasoning with this extension can be implemented in existing first-order theorem provers. The extension is called \folb{}, standing for first-order logic (FOL) with boolean sort. \folb{} differs from the ordinary many-sorted FOL in that it \begin{enumerate*}[label=(\roman*)]\item contains an interpreted boolean sort and treats boolean terms as formulas; \item supports \ITE\ expressions; and \item supports \LETIN\ expressions.\end{enumerate*}

The main contributions of the thesis are the following:
\begin{enumerate}
  \item the definition of \folb{} and its semantics;
  \item a translation from \folb{} formulas to formulas of first-order logic, which can be used to support \folb{} in existing first-order provers;
  \item a new technique of dealing with the boolean sort in superposition theorem provers that includes replacement of one of the boolean sort axioms with a specialised inference rule;
  \item a modification to the TPTP language that makes it compatible with \folb{};
  \item an implementation of reasoning in \folb{} in the Vampire theorem prover;
  \item experimental results showing usability and high performance of the implementation of \folb{} in Vampire on a series of benchmarks;
  \item a translation of \folb{} formulas to first-order clauses that can produce smaller CNFs than the ones obtained by clausification of \folb{} formulas translated to first-order logic;
  \item an implementation of this translation in Vampire;
  \item experimental results showing an increase in performance of Vampire on \folb{} problems thanks to the translation of \folb{} formulas directly to first-order clauses;
  \item a simple extension of \folb{}, allowing to express the next state relation of a program as a boolean formula which is linear in the size of the program.
\end{enumerate}

The thesis focuses on practical features extending first-order theorem provers for making them better suited for applications of program verification and proof automation for interactive theorem provers. While the thesis describes implementation details and challenges in the Vampire theorem prover, the described features and their implementation can be carried out in any other first-order prover.

The thesis describes a modification of the TPTP language needed to represent \folb{} formulas. This modification will be included in the future TPTP standard.

\folb{} contains features of higher-order logic. Some problems that previously required higher-order logic can now be expressed directly in \folb{}. For example, the current version of the TPTP library contains over a hundred of such problems. One can check these problems with first-order provers that support \folb{} rather than higher-order provers. 

\folb{} can be regarded as the smallest logic containing both the core theory of SMT-LIB~\cite{SMT-LIB} (the standard library of problems for SMT solvers) and the monomorphic first-order part of the TPTP language~\cite{tff0}. First-order provers that support \folb{} can therefore reason about some problems from the SMT-LIB library. This opens up an opportunity to evaluate first-order provers on problems that were previously only checked by SMT solvers.

The work described in this thesis has been carried out in three papers, each presented in a separate chapter. Two papers (Chapters~\ref{chap:fool} and~\ref{chap:implementation}) were published in peer-reviewed conferences, and one (Chapter~\ref{chap:cnf}) is currently being prepared for submission to a peer-reviewed conference. The references of the papers have been combined into a single bibliography at the end of the thesis. Other than that, the papers have only been edited for formatting purposes, and in general appear in their original form. The contributions of the thesis are the cumulative contributions of all the papers. The rest of this chapter details the main contributions of each individual paper.

\subsection*{Chapter \ref{chap:fool}. A First Class Boolean Sort in\\First-Order Theorem Proving and TPTP}
The paper presents the syntax and semantics of \folb. We show that \folb\ is a modification of FOL and reasoning in it reduces to reasoning in FOL. We give a model-preserving \iffalse(modulo introduced definitions)\fi translation of \folb\ to FOL that can be used for proving theorems in \folb\ in a first-order prover. We discuss a modification of superposition calculus that can reason efficiently in the presence of boolean sort. This modification includes replacement of one of the boolean sort axioms with a specialised inference rule that we called \folb\ paramodulation. We note that the TPTP language can be changed to support \folb, which will also simplify some parts of the TPTP syntax. 

\paragraph{Statement of contribution.} The paper is co-authored with Laura Kov\'{a}cs and Andrei Voronkov. Evgenii Kotelnikov contributed to the formalisation of \folb{} and its translation to FOL.

This paper has been published in the proceedings of the 8th Conference on Intelligent Computer Mathematics (CICM) in 2015.

\subsection*{Chapter \ref{chap:implementation}. The Vampire and the \folb{}}
The paper describes the implementation of \folb\ in Vampire. We extend and simplify the TPTP language by providing more powerful and uniform representations of \ITE\ and \LETIN\ expressions. We demonstrate usability and high performance of our implementation on two collections of benchmarks, coming from the higher-order part of the TPTP library and from the Isabelle interactive theorem prover. We compare the results of running Vampire on the benchmarks with those of SMT solvers and higher-order provers. Moreover, we compare the performance of Vampire with and without \folb{} paramodulation. We give a simple extension of \folb, allowing to express the next state relation of a program as a boolean formula which is linear in the size of the program.

\paragraph{Statement of contribution.} The paper is co-authored with Laura Kov\'{a}cs, Giles Reger and Andrei Voronkov. Evgenii Kotelnikov contributed with the implementation of \folb{} in Vampire and the experiments.

This paper has been published in the proceedings of the 5th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP) in 2016.

\subsection*{Chapter \ref{chap:cnf}. A Clausal Normal Form Translation\\for \folb{}}
The paper presents a clausification algorithm that translates a FOOL formula to an equisatisfiable set of first-order clauses. This algorithm aims to minimise the number of clauses and the size of the resuting signature, especially on formulas with \ITE, \LETIN\ expressions and complex boolean structure. We demonstrate by experiments that the implementation of this algorithm in Vampire increases performance of the prover on \folb{} problems compared to the earlier translation of \folb{} formulas to full first-order logic.

\paragraph{Statement of contribution.} The paper is co-authored with Laura Kov\'{a}cs, Martin Suda and Andrei Voronkov. Evgenii Kotelnikov contributed with the extension of \newcnf{} that supports \folb{}, the implementation of this extension in Vampire and the experiments.

\subsection*{Chapter \ref{chap:boogie}. A FOOLish Encoding of the Next State Relations of Imperative Programs}
\EK{TODO}

\paragraph{Statement of contribution.} The paper is co-authored with Laura Kov\'{a}cs and Andrei Voronkov. Evgenii Kotelnikov contributed with \EK{TODO}