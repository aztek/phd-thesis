% !TEX root = ../main.tex

%Section~\ref{sec:boogie/next-state/translation} described a translation from imperative programs to FOOL formulas that encode the partial correctness properties of these programs. These partial correctness properties can be automatically checked by a theorem prover that supports reasoning with FOOL. 
In this section we describe our experiments on comparing the performance of the Vampire theorem prover~\cite{Vampire13} on FOOL and on translations of program properties to FOL. We used a collection of 50 programs written in the Boogie verification language~\cite{leino2008boogie}. Each of these programs uses only variable assignments, \ITE\ statements, and sequential composition and is annotated with its pre-conditions and post-conditions, expressed in first-order logic. From this collection of programs we generated the following three sets of benchmarks.

% We also compare our work to SMT-based verification, in particular to the SMT solver Z3~\cite{Z3} for proving partial correctness of programs formulated as SMT-LIB formulas~\cite{BarFT-SMTLIB}.

%We run Vampire on a set of benchmarks that encode partial correctness problems. We generated these problems from our collection of imperative programs using \begin{enumerate*}[label=(\roman*)]\item the front end of the Boogie~\cite{DBLP:conf/fmco/BarnettCDJL05} verifier, \item our implementation of the translation from Section~\ref{sec:boogie/next-state/translation} named Voogie, and \item the BLT~\cite{CF-iFM17} translator\end{enumerate*}.

\begin{enumerate}
  \item 50 problems in first-order logic written in the SMT-LIB language~\cite{SMT-LIB}. We generated these problems by running the front end of the Boogie~\cite{DBLP:conf/fmco/BarnettCDJL05} verifier.
  \item 50 FOOL problems with tuples generated by running our implementation of the translation from Section~\ref{sec:boogie/next-state/translation}, named Voogie.
  \item 50 FOOL problems generated by running the BLT~\cite{CF-iFM17} translator.
\end{enumerate}

We point out that in our experiments we do not aim to compare methods of program verification or specific verification tools. Rather, we compare different ways of translating realistic verification problems for theorem provers.

In what follows, we describe the collection of imperative programs used in our experiments (Section~\ref{sec:boogie/experiments/programs}) and discuss our set of benchmarks (Section~\ref{sec:boogie/experiments/problems}). All properties that we deal with use integers and arrays, as well as universal and existential quantifiers. To verify these properties one has to reason in the combination of theories and quantifiers. We briefly describe how Vampire implements this kind of reasoning in Section~\ref{sec:boogie/experiments/vampire}. Our experimental results are summarised in Tables~\ref{table:boogie/boogie-results}--\ref{table:boogie/blt-results} and discussed in Section~\ref{sec:boogie/experiments/results}.

\newcommand{\bad}{\mathit{bad}}
\newcommand{\iter}{i}

\subsection{Examples of Imperative Programs}\label{sec:boogie/experiments/programs}
We demonstrate the work of our translation on a collection of imperative programs that only use variable assignments, \ITE\ statements, and sequential composition. Unfortunately, no large collections of such programs are available. There are many benchmarks for software verification tools, but most of them use control flow statements not covered in this work, such as gotos and exceptions. We also cannot use benchmarks from the hardware verification and model checking communities, because they are mostly about boolean values and bit-vectors. For our experiments we generated our own imperative programs in two steps described below.

%\begin{enumerate}
%  \item 
First, we crafted 10 programs that implement textbook algorithms and solutions to program verification competitions. Each program uses variables of the integer, boolean, and array type. Each program contains a single \verb'while' loop
of the form $\while{\expr}{\stmt}$, where $\expr$ is a boolean expression and $\stmt$ is a statement. In addition, each program contains 
variable assignments, \ITE\ statements, and sequential composition. We annotated each program with its pre-condition $\varphi$ and each loop with its invariant $\psi$. The formulas $\varphi$ and $\psi$ are expressed in first-order logic.
%  \item

Then, we unrolled the loop of each program $k$ times, where $k$ is an integer between 1 and 5. This resulted in 50 loop-free programs that retain the annotated properties.
%Using the notation above, the pre-condition of this loop-free annotated program is $\varphi \wedge \chi$. The post-condition states that $\psi$ holds after exactly $k$ iterations of the loop. We expressed the post-condition as $\neg\bad \implies \psi$, where $\bad$ is a fresh boolean variable. $\bad$ encodes the under-specified state of the program. $\bad$ is set to $\true$ before each unrolled iteration of the loop if $\expr$ does not hold, and at the end of the program if $\expr$ does hold.
%
%\end{enumerate}
%
%Each of the 10 programs with loops consists of declarations of variables and a single loop of the form $\while{\expr}{\stmt}$, where $\expr$ is a boolean expression and $\stmt$ is a statement. $\expr$ and $\stmt$ fit the definitions of an expression and a statement, respectively, given in Section~\ref{sec:boogie/technique}. Each program is annotated with its pre-condition $\varphi$ and its post-condition $\psi$, and each loop is annotated with its loop invariant $\chi$. $\varphi$, $\psi$, and $\chi$ are formulas in first-order logic.
%
%While transforming programs with loops into loop-free programs by taking finite unrollings of the loop, we also annotated the resultin loop-free programs We transformed each program with a loop into an annotated program by unrolling the loop $k \ge 1$ times. 
%The pre-condition of this annotated program is $\varphi \wedge \chi$. The post-condition states that $\psi$ holds after exactly $k$ iterations of the loop. We expressed the post-condition as $\neg\bad \implies \psi$, where $\bad$ is a fresh boolean variable. $\bad$ encodes the underspecified state of the program. $\bad$ is set to $\true$ before each unrolled iteration of the loop if $\expr$ does not hold, and at the end of the program if $\expr$ does hold.
%\end{enumerate}
Each program encodes the loop invariant property of the original program. 
% AV : commented out since not true in view of pre-conditions:
% While in order to verify a loop invariant one only needs to unroll the loop once,
Multiple unrollings provide us with programs with long sequences of variables updates, \ITE\ statements and compositions, which are convenient for our experiments.
%
%In summary, our loop unrolling program transformation consisted of the following steps.
Our loop unrolling program transformation consisted of the following steps.
\begin{enumerate}
  \item Introduce a fresh boolean variable $\bad$ that encodes the under-specified state of the program.
  \item Construct a guarded loop iteration $\iter$ as $$\seq{\ite{\neg e}{\assigns{\bad}{\true}}{\emptyStatement}}{\stmt}.$$
  \item Construct a sequence of iterations $\seq{\seq{\iter}{\ldots}}{\iter}$, where $\iter$ is repeated $k$ times. 
  \item Finally, construct the annotated program $$\hoare{\varphi \wedge \psi}{\seq{\seq{\iter}{\ldots}}{\iter}}{\neg\bad \implies \psi}.$$
\end{enumerate}

It is not hard to show that if a program with a loop satisfies its specification, then the Hoare triple resulting in step 4 of the above transformation also holds. 

%Let us make the following remark regarding our examples and their formalisation in Boogie.
We wrote our example programs with loops as well as their loop-free unrolled versions in the Boogie language. Boogie can unroll loops automatically, but introduces \verb'goto' statements that our translation does not support. For this reason, we used the loop unrolling described above. 

%Each of our Boogie programs implements a single procedure \verb'main'. We annotated every procedure with its pre-conditions using the keyword \verb'requires' and its post-conditions using the keyword \verb'ensures'. We annotated each loop with its invariants using the keyword \verb'invariant'. Some of our programs use multidimensional arrays. Boogie supports both multidimensional arrays and nested arrays. We used the latter to represent our programs.

An example of our loop unrolling is available at \url{http://www.cse.chalmers.se/~evgenyk/ijcar18/}. It shows the \texttt{maxarray} program with a loop from our collection and a program generated from \texttt{maxarray} by unrolling its loop twice.

%Appendix~\ref{sec:boogie/appendix} contains an example of our loop unrolling. Figure~\ref{fig:boogie/loop} shows the \texttt{maxarray} program with a loop\footnote{This program is a solution to Challenge 1 of COST IC0701 Verification Competition 2011.} from our collection and Figure~\ref{fig:boogie/loop-free} shows a program generated from \verb'maxarray' by unrolling its loop twice. 

\subsection{Benchmarks}\label{sec:boogie/experiments/problems}
We used the 50 annotated loop-free programs and generated their partial correctness statements using Boogie, Voogie and BLT. These statements are encoded as unsatisfiable problems in first-order logic and FOOL.
Our collection of imperative programs with loops, their loop-free unrollings and benchmarks expressed in the TPTP language \cite{TPTP} is available at \url{http://www.cse.chalmers.se/~evgenyk/ijcar18/}. The TPTP benchmarks are also available, along with other FOOL problems, on the TPTP website \url{http://tptp.org}.

The Boogie verifier generates verification conditions as formulas in first-order logic written in the SMT-LIB language and uses the SMT solver Z3~\cite{Z3} to check these formulas. We ran Boogie with the option \verb'/proverLog' to print the generated formulas on each of our annotated loop-free programs and in this way obtained a collection of 50 SMT-LIB benchmarks.

Voogie is our implementation of the translation described in Section~\ref{sec:boogie/technique}. It takes as input programs written in a fragment of the Boogie language and generates FOOL formulas written in the TPTP language. The source code of Voogie is available at \url{https://github.com/aztek/voogie}.

The fragment of the Boogie language supported by Voogie can be seen as the smallest fragment that is sufficient to represent the loop-free programs in our collection. This fragment consists of
\begin{enumerate*}[label=(\roman*)]
  \item top level variable declarations;
  \item a single procedure \verb'main' annotated with its pre- and post-conditions;
  \item assignments to variables, including parallel assignments, and assignments to array elements;
  \item \ITE\ statements; and
  \item arithmetic and boolean operations.
\end{enumerate*}
% \begin{enumerate}
%   \item Top level variable declarations of types \verb'int', \verb'bool', or the type of nested arrays.
%   \item A single procedure \verb'main' with property annotations marked with keywords \verb'requires' and \verb'ensures'.
%   \item Assignments to variables, including parallel assignments, and assignments to array elements.
%   \item \ITE\ statements.
%   \item Arithmetic and boolean operations.
% \end{enumerate}
Running Voogie on each loop-free program in our collection gave us 50 TPTP benchmarks.
An example of the TPTP benchmark obtained from running Voogie on the \texttt{maxarray} program with its loops unrolled twice is available at \url{http://www.cse.chalmers.se/~evgenyk/ijcar18/}.
%Figure~\ref{fig:boogie/loop-free-translation} in Appendix~\ref{sec:boogie/appendix} shows the TPTP code of the partial correctness property of the program from Figure~\ref{fig:boogie/loop-free} obtained with Voogie. 

BLT (Boogie Less Triggers)~\cite{CF-iFM17} is an automatic tool that takes Boogie programs as input and generates their verification conditions in first-order logic written in the TPTP language. BLT has an experimental feature of generating FOOL formulas with tuple \LETIN\ and tuple expressions to represent next state values of program variables in a style similar to Voogie. At the time of our experiments, this feature was not stable enough, and we did not enable it. Running BLT with its default configuration on each of the 50 loop-free programs in our collection gave us 50 TPTP benchmarks.

The representation of program expressions coincides in all three translations. All translations use the theory of linear integer arithmetic and the theory of arrays as realised in their respective languages.

% The translations represent sequences of \ITE\ statements and variable assignments differently. We summarise the differences below.

% The Boogie translation (see~\cite{DBLP:journals/ipl/Leino05} for details)
% \begin{enumerate}
%   \item introduces a fresh constant for each state of each program variable;
%   \item encodes each variable assignment as logical equality and each sequence of assignments as logical conjunction;
%   \item introduces a fresh boolean constant for each branch of each \ITE\ statement. Each such constant is defined using a \LETIN\ expression and encodes the next state relation of the branch.
% \end{enumerate}

% The Voogie translation 
% \begin{enumerate}
%   \item does not introduce any new symbols;
%   \item encodes each variable assignment using a \LETIN\ expression;
%   \item encodes each \ITE\ statement as a \ITE\ expression inside a \LETIN\ expression with a tuple definition.
% \end{enumerate}

% The BLT translation (see~\cite{CF-iFM17} for details)
% \begin{enumerate}
%   \item encodes each variable assignment using a \LETIN\ expression;
%   \item encodes each \ITE\ statement as a \ITE\ expression;
%   \item duplicates the post-condition of the program in each branch of \ITE.
% \end{enumerate}

\subsection{Theories and Quantifiers in Vampire}\label{sec:boogie/experiments/vampire}
Vampire's main algorithm is saturation of a set of first-order clauses using the resolution and superposition calculus. Vampire also implements the AVATAR architecture~\cite{DBLP:conf/cav/Voronkov14} for splitting clauses. The idea behind AVATAR is to use a SAT or an SMT solver to guide proof search. AVATAR selects sub-problems for the saturation-based prover to tackle by making decisions over a propositional abstraction of the clause search space. The \verb'-sas' option of Vampire selects the SAT solver.

Vampire handles theories by automatically adding theory axioms to the search space whenever an interpreted sort, function, or predicate is found in the input. This approach is incomplete for theories such as linear and non-linear integer and real arithmetic, but shows good results in practice. The \verb'-tha' option of Vampire with values \verb'on' and \verb'off' controls whether theory axioms are added.

A recent work~\cite{DBLP:conf/gcai/RegerB0V16} lifted AVATAR to be modulo theories by replacing the SAT solver by an SMT solver, ensuring that the sub-problem is theory-consistent in the ground part. The result is that the saturation prover and the SMT solver deal with the parts of the problem to which they are best suited. Vampire implements AVATAR modulo theories using Z3.

Our experience with running Vampire on theory- and quan\-ti\-fi\-er-in\-ten\-si\-ve problems shows that some of the theory axioms can degrade the performance of Vampire. These axioms make Vampire infer many theory tautologies making the search space larger. We found that, among others, axioms of commutativity, associativity, left and right identity, and left and right inverse of arithmetic operations are in this sense ``expensive''. Our solution to this problem is a more refined control over which theory axioms Vampire adds to the search space. We added to the \verb'-tha' option of Vampire a new value named \verb'some' that makes Vampire only add ``cheap'' axioms to the search space. \verb'some' implements our empirical criterion for choosing theory axioms. Designing other criteria for axiom selection is an interesting task for future work.

%Cheap: non-reflexivity, transitivity, total order, plus one greater.
%Expensive: commutativity, associativity, right identity, left identity, commutative group axioms, right inverse, monotonicity of $+$.

\subsection{Experimental Results}\label{sec:boogie/experiments/results}
For our experiments, we compared the performance of Vampire on the Boogie, Voogie, and BLT translations of our benchmarks. 
%We also compared the performance of Vampire with that of Z3 on the SMT-LIB benchmarks. Z3 cannot read input in TPTP and does not support tuples, therefore we could not run it on the TPTP benchmarks.

We ran Vampire on all three sets of benchmarks with options \verb'-tha some' and \verb'-sas z3'. Vampire supports both TPTP and SMT-LIB syntax, the input language is selected by setting the \verb'--input_syntax' option to \verb'tptp' and \verb'smtlib2', respectively. We performed our experiments on the StarExec compute cluster~\cite{starexec} using the time limit of 5 minutes per problem. The detailed experimental results are available at \url{http://www.cse.chalmers.se/~evgenyk/ijcar18/}.

\begin{table}\center
  \caption{Runtimes in seconds of Vampire on the Boogie translation of the benchmarks.}
  \label{table:boogie/boogie-results}
  \begin{tabular}[ht]{lrrrrr}
\hline
\multirow{2}{*}{Benchmark} & \multicolumn{5}{c}{Number of loop unrollings} \\ %\cline{2-6}
& \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} \\
\hline
binary-search    & 0.884 & 2.420 & 3.364 & 10.709 & 27.648 \\
bubble-sort      & -- & -- & -- & -- & -- \\
dutch-flag       & 24.789 & -- & -- & -- & -- \\
insertion-sort   & 122.354 & -- & -- & -- & -- \\
matrix-transpose & 1.311 & -- & 1.078 & -- & -- \\
maxarray         & 0.205 & 0.587 & 1.197 & 1.702 & 1.692 \\
maximum          & 0.066 & 0.078 & 0.082 & 0.095 & 0.129 \\
one-duplicate    & -- & -- & -- & -- & -- \\
select-k         & 96.993 & -- & -- & -- & -- \\
two-way-sort     & 0.191 & 0.205 & 0.647 & 1.384 & 1.344 \\
  \end{tabular}
\end{table}

\begin{table}\center
  \caption{Runtimes in seconds of Vampire on the Voogie translation of the benchmarks.}
  \label{table:boogie/voogie-results}
  \begin{tabular}[ht]{lrrrrr}
\hline
\multirow{2}{*}{Benchmark} & \multicolumn{5}{c}{Number of loop unrollings} \\ %\cline{2-6}
& \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} \\
\hline
binary-search    &  1.979 & 25.135 &   6.560 &     -- & 163.803 \\
bubble-sort      &  0.394 & 53.192 &   2.073 &     -- &      -- \\
dutch-flag       & 11.384 &     -- &      -- &     -- &      -- \\
insertion-sort   & 18.262 & 38.169 &   3.369 & 21.698 &  11.639 \\
matrix-transpose &  0.266 &  8.362 &      -- &     -- &      -- \\
maxarray         &  0.170 &  0.587 &   0.489 &  2.635 &   6.325 \\
maximum          &  0.062 &  0.065 &   0.070 &  0.087 &   0.102 \\
one-duplicate    &  0.125 &  2.402 &   2.231 & 93.746 & 145.243 \\
select-k         &  0.216 &  0.612 & 203.655 &     -- &      -- \\
two-way-sort     &  0.464 &  5.360 &      -- &     -- &      -- \\
  \end{tabular}
\end{table}

Tables~\ref{table:boogie/boogie-results} and \ref{table:boogie/voogie-results} summarise the results of Vampire on the Boogie and Voogie translations of the benchmarks, respectively. A dash means that Vampire does not solve the problem within the given time limit.
\begin{itemize}
  \item Vampire solves 25 of the problems, translated by Boogie, and 36 problems, translated by Voogie.
  \item For 16 benchmark programs, Vampire solves their Voogie translations, but not the Boogie translations.
  \item For 5 benchmark programs, Vampire solves their Boogie translations, but not the Voogie translations.
  \item For 20 benchmark programs, Vampire solves both of their translations, and is faster on the Voogie translations for 12 of them.
%  \item Vampire solved either one of the two translations for 43 of the 50 benchmark programs.
\end{itemize}

Table~\ref{table:boogie/blt-results} summarises the results of Vampire on the BLT translations of the benchmarks.
\begin{itemize}
  \item Vampire solves 19 of the problems, translated by BLT.
  \item For all benchmark programs whose BLT translation Vampire is able to solve, Vampire also solves their Voogie translations. There are 3 benchmark programs for which Vampire solves their BLT translations but not their Boogie translations.
\end{itemize}

\begin{table}\center
  \caption{Runtimes in seconds of Vampire on the BLT translation of the benchmarks.}
  \label{table:boogie/blt-results}
  \begin{tabular}[ht]{lrrrrr}
\hline
\multirow{2}{*}{Benchmark} & \multicolumn{5}{c}{Number of loop unrollings} \\ %\cline{2-6}
& \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} \\
\hline
binary-search    & 0.821 & 163.790 &     -- &     -- & -- \\
bubble-sort      & 3.511 &      -- &     -- &     -- & -- \\
dutch-flag       & 4.049 &      -- &     -- &     -- & -- \\
insertion-sort   & 1.780 &      -- &     -- &     -- & -- \\
matrix-transpose & 0.465 &  12.437 &     -- &     -- & -- \\
maxarray         & 0.174 &   1.567 & 47.724 &     -- & -- \\
maximum          & 0.069 &   0.140 &  0.724 & 12.234 & -- \\
one-duplicate    & 0.307 &  10.039 &     -- &     -- & -- \\
select-k         & 3.142 &      -- &     -- &     -- & -- \\
two-way-sort     & 0.319 &  24.622 &     -- &     -- & -- \\
  \end{tabular}
\end{table}

Based on the results presented in Tables~\ref{table:boogie/boogie-results}--\ref{table:boogie/blt-results} we make the following observation. The problems translated from our benchmarks by Voogie are easier for Vampire than the problems translated by Boogie and BLT. Vampire is more efficient both in terms of the number of solved problems and runtime on the problems translated by Voogie. 
%We explain this observation by the fact that the Voogie translation uses tuple expressions and \LETIN\ with tuple definitions, which results in a succinct representation of the program inside the theorem prover. We conclude that by representing partial correctness of imperative programs directly as FOOL formulas we leverage the capabilities of Vampire.
This confirms our conjecture that the use of (efficient translations of) FOOL is better for saturation theorem provers than translations to FOL designed for other purposes. It would be interesting to run these experiments for theorem provers other than Vampire, however Vampire is currently the only prover implementing FOOL.

%Table~\ref{table:boogie/z3-results} summarises the results of Z3 on the SMT-LIB benchmarks. Z3 solved all the problems and showed good performance on all of them. 

%Based on our experimental resultn shows in Tables~\ref{table:boogie/tptp-results} and \ref{table:boogie/smtlib-results} we make the following observations.

%The detailed experimental results are available at \url{http://www.cse.chalmers.se/~evgenyk/ijcar18/}.



%\begin{table}
%  \caption{Runtimes in seconds of Z3 on the SMT-LIB translations of the benchmarks.}
%\scalebox{\tableScale}{
 % \begin{tabular}{lrrrrr}
%\hline
%\multirow{2}{*}{Benchmark} & \multicolumn{5}{c}{Number of loop unrollings} \\ %\cline{2-6}
%& \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} \\
%\hline
%binary-search    & 0.018 & 0.025 & 0.040 & 0.066 & 0.114 \\
%bubble-sort      & 0.024 & 0.041 & 0.070 & 0.114 & 0.181 \\
%dutch-flag       & 0.021 & 0.048 & 0.130 & 0.395 & 1.327 \\
%insertion-sort   & 0.022 & 0.032 & 0.051 & 0.086 & 0.133 \\
%matrix-transpose & 0.017 & 0.022 & 0.028 & 0.042 & 0.052 \\
%maxarray         & 0.018 & 0.023 & 0.031 & 0.048 & 0.072 \\
%maximum          & 0.015 & 0.016 & 0.019 & 0.022 & 0.028 \\
%one-duplicate    & 0.017 & 0.020 & 0.026 & 0.039 & 0.050 \\
%select-k         & 0.020 & 0.029 & 0.044 & 0.074 & 0.129 \\
%two-way-sort     & 0.017 & 0.026 & 0.047 & 0.098 & 0.218 \\
 % \end{tabular}
%}
%  \label{table:boogie/z3-results}
%\end{table}