% !TEX root = ../main.tex

Automated program analysis and verification requires
discovering and proving program properties. Typical examples of such properties are loop invariants or Craig interpolants. These properties usually are expressed in combined theories of various data structures, such as integers and arrays, and hence require reasoning with both theories and quantifiers. Recent approaches in interpolation and loop invariant generation~\cite{McMillan08,fase2009,hoder2012popl} present initial results of using first-order theorem provers for generating quantified program properties. First-order theorem provers can also be used to generate program properties with quantifier alternations~\cite{fase2009}; such properties could not be generated fully automatically by any previously known method.
Using first-order theorem prover to generate, and not only prove program properties, opens new directions in analysis and verification of real-life programs.

First-order theorem provers, such as iProver~\cite{iProver}, E~\cite{E13}, and Vampire~\cite{Vampire13}, lack however various features that are crucial for program analysis. For example, first-order theorem provers do not yet efficiently handle (combinations of) theories;
nevertheless, sound but incomplete theory axiomatisations can be used in a first-order prover even for theories having no finite axiomatisation. Another difficulty in modelling properties arising in program analysis using theorem provers is the gap between the semantics of expressions used in programming languages and expressiveness of the logic used by the theorem prover. A similar gap exists between the language used in presenting mathematics. For example, a standard way to capture assignment in program analysis is to use a \LETIN\ expression, which introduces a local binding of a variable, or a function for array assignments, to a value. There is no local binding expression in first-order logic, which means that any modelling of imperative programs using first-order theorem provers at the backend, should implement a translation of \LETIN\ expressions. Similarly, mathematicians commonly use local definitions within definitions and proofs. Some functional programming languages also contain expressions introducing local bindings. In all three cases, to facilitate the use of first-order provers, one needs a theorem prover implementing \LETIN\ constructs natively.

Efficiency of reasoning-based program analysis largely depends on how programs are translated into a collection of logical formulas capturing the program semantics. The boolean structure of a program property that can be efficiently treated by a theorem prover is however very sensitive to the architecture of the reasoning engine of the prover. Deriving and expressing program properties in the ``right'' format therefore requires solid knowledge about how theorem provers work and are implemented~--- something that a user of a verification tool might not have. Moreover, it can be hard to efficiently reason about certain classes of program properties, unless special inference rules and heuristics are added to the theorem prover, see e.g.~\cite{ATVA14} when it comes to prove properties of data collections with extensionality axioms.

In order to increase the expressiveness of program properties generated by reasoning-based program analysis, the language of logical formulas accepted by a theorem prover needs to be extended with constructs of programming languages. This way, a straightforward translation of programs into first-order logic can be achieved, thus relieving users from designing translations which can be efficiently treated by the theorem prover.
One example of such an extension is recently added to the TPTP language~\cite{TPTP} of first-order theorem provers, resembling \ITE\ and \LETIN\ expressions that are common in programming languages. Namely, special functions \lstinline'$ite_t' and \lstinline'$ite_f' can respectively be used to express a conditional statement on the level of logical terms and formulas, and \lstinline'$let_tt', \lstinline'$let_tf', \lstinline'$let_ff' and \lstinline'$let_ft' can be used to express local variable bindings for all four possible combinations of logical terms (\lstinline't') and formulas (\lstinline'f'). While satisfiability modulo theory (SMT) solvers, such as Z3~\cite{Z3} and CVC4~\cite{CVC4}, integrate \ITE\ and \LETIN\ expressions, in the first-order theorem proving community so far only Vampire supports such expressions.

To illustrate the advantage of using \ITE\ and \LETIN\ expressions in automated provers, let us consider the following example. We are interested in verifying the partial correctness of the code fragment below:
% \pagebreak
\begin{lstlisting}[language=cpp]
if (r(a)) {
  a := a + 1
} else {
  a := a + q(a)
}
\end{lstlisting}
using the pre-condition $((\forall x) P(x) \Rightarrow x \ge 0) \wedge ((\forall x) \mathtt{q}(x) > 0) \wedge P(\mathtt{a})$ and the post-condition $\mathtt{a} > 0$.
Let $\mathtt{a1}$ denote the value of the program variable $\mathtt{a}$ after the execution of the \verb'if' statement. Using \ITE\ and \LETIN\ expressions, the next state function for $\mathtt{a}$ can naturally be expressed by the following formula:
\begin{lstlisting}[language=cpp]
a1 = if r(a) then let a = a + 1 in a
             else let a = a + q(a) in a
\end{lstlisting}

This formula can further be encoded in TPTP, and hence used by a theorem prover as a hypothesis in proving partial correctness of the above code snippet. We illustrate below the TPTP encoding of the first-order problem corresponding to the partial program correctness problem we consider.  Note that the pre-condition becomes a hypothesis in TPTP, whereas the proof obligation given by the post-condition is a TPTP conjecture. All formulas below are typed first-order formulas (\lstinline'tff') in TPTP that use the built-in integer sort (\lstinline'$int').
\begin{lstlisting}[language=tptp]
tff(1, type, p: $int > $o).
tff(2, type, q: $int > $int).
tff(3, type, r: $int > $o).
tff(4, type, a: $int).
tff(5, hypothesis, ![X: $int]: (p(X) => $greatereq(X, 0))).
tff(6, hypothesis, ![X: $int]: ($greatereq(q(X), 0))).
tff(7, hypothesis, p(a)).
tff(8, hypothesis,
    a1 = $ite_t(r(a), $let_tt(a, $sum(a, 1), a),
                      $let_tt(a, $sum(a, q(a)), a))).
tff(9, conjecture, $greater(a1, 0)).
\end{lstlisting}

Running a theorem prover that supports \lstinline'$ite_t' and \lstinline'$let_tt' on this TPTP problem would prove the partial correctness of the program we considered. Note that without the use of \ITE\ and \LETIN\ expressions, a more tedious translation is needed for expressing the next state function of the program variable $\mathtt{a}$ as a first-order formula. When considering more complex programs containing multiple conditional expressions assignments and composition,
computing the next state function of a program variable results in a formula of size exponential in the number of conditional expressions. This problem of computing the next state function of variables is well-known in the program analysis community, by computing so-called static single assignment (SSA) forms. Using the \ITE\ and \LETIN\ expressions recently introduced in TPTP and already implemented in Vampire \cite{PSI14}, one can have a linear-size translation instead.

Let us however note that the usage of conditional expressions in TPTP is somewhat limited. The first argument of \lstinline'$ite_t' and \lstinline'$ite_f' is a logical formula, which means that a boolean condition from the program definition should be translated as such. At the same time, the same condition can be treated as a value in the program, for example, in a form of a boolean flag, passed as an argument to a function. Yet we cannot mix terms and formulas in the same way in a logical statement.
A possible solution would be to map the boolean type of programs to a user-defined boolean sort, postulate axioms about its semantics, and manually convert boolean terms into formulas where needed. This approach, however, suffers the disadvantages mentioned earlier, namely the need to design a special translation and its possible inefficiency.

Handling boolean terms as formulas is needed not only in applications of reasoning-based program analysis, but also in various problems of formalisation of mathematics.
For example, if one looks at two largest kinds of attempts to formalise mathematics and proofs: those performed by interactive proof assistants, such as Isabelle~\cite{Isabelle},  and the Mizar project~\cite{Mizar}, one can see that first-order theorem provers are the main workhorses behind computer proofs in both cases~--- see e.g.~\cite{Sledgehammer,DBLP:conf/icms/UrbanHV10}.
Interactive theorem provers, such as Isabelle routinely use quantifiers over booleans.  Let us illustrate this by the
following examples, chosen among 490 properties about (co)algebraic datatypes, featuring quantifiers over booleans, generated by Isabelle and kindly found for us by Jasmin Blanchette. Consider the distributivity of a conditional expression (denoted by the $\mathrm{ite}$ function) over logical connectives, a pattern that is widely used in reasoning about properties of data structures. For lists and the $\mathtt{contains}$ function that checks that its second argument contains the first one, we have the following example:
\begin{gather}\label{formula:contains}
  \begin{aligned}
&(\forall\ofsort{p}{\bool})(\forall\ofsort{l}{list_A})(\forall\ofsort{x}{A})(\forall\ofsort{y}{A}) \\
&\quad\mathtt{contains}(l,\mathrm{ite}(p,x,y)) \doteq \\
&\quad\quad(p \Rightarrow \mathtt{contains}(l,x)) \wedge (\neg p \Rightarrow \mathtt{contains}(l,y))
 \end{aligned}
\end{gather}

A more complex example with a heavy use of booleans is the unsatisfiability of the definition of $\mathtt{subset\_sorted}$.
\begin{gather}\label{formula:subset-sorted}
\begin{aligned}
&(\forall\ofsort{l_1}{list_A})(\forall\ofsort{l_2}{list_A})(\forall\ofsort{p}{\bool}) \\
&\hspace{0.5em}\neg (\mathtt{subset\_sorted}(l_1,\,l_2) \doteq p ~\wedge \\
&\hspace{1.6em}      (\forall\ofsort{l_2'}{list_A})\neg (l_1 \doteq \mathtt{nil} \wedge l_2 \doteq l_2' \wedge p) ~\wedge \\
&\hspace{1.6em}      (\forall\ofsort{x_1}{A})(\forall\ofsort{l_1'}{list_A})\neg (l_1 \doteq \mathtt{cons}(x_1,\,l_1') \wedge l_2 \doteq \mathtt{nil} \wedge \neg p) ~\wedge \\
&\hspace{1.6em}      (\forall\ofsort{x_1}{A})(\forall\ofsort{l_1'}{list_A})(\forall\ofsort{x_2}{A})(\forall\ofsort{l_2'}{list_A}) \\
&\hspace{2.1em}       \neg (l_1 \doteq \mathtt{cons}(x_1,\,l_1') \wedge l_2 \doteq \mathtt{cons}(x_2,\,l_2') ~\wedge \\
&\hspace{3.3em}       p \doteq \mathrm{ite}(x_1 < x_2,\,\false,\\
&\hspace{6.7em}                             \mathrm{ite}(x_1 \doteq x_2,\mathtt{subset\_sorted}(l_1',\,l_2'), \\
&\hspace{12.1em}                                        \mathtt{subset\_sorted}(\mathtt{cons}(x_1,\,l_1'),\,l_2')))))
\end{aligned}
\end{gather}
The $\mathtt{subset\_sorted}$ function takes two sorted lists and checks that its second argument is a sublist of the first one.

Problems with boolean terms are also common in the SMT-LIB project~\cite{SMT-LIB}, the collection of benchmarks for SMT-solvers. Its core logic is a variant of first-order logic that treats boolean terms as formulas, in which logical connectives and conditional expressions are defined in the core theory.

%Note in particular that this formula employes quantification over boolean variables and passing boolean terms as arguments to logical connectives, that would not be admissible in ordinary first-order logic.

In this paper we propose a modification \folb\ of first-order logic, which includes a first-class boolean sort and \ITE\ and \LETIN\ expressions, aimed for being used in automated first-order theorem proving. It is the smallest logic that contains both the SMT-LIB core theory and the monomorphic first-order subset of TPTP. The syntax and semantics of the logic are given in Section~\ref{sec:folbool}.
%In this paper we propose a modification of first-order logic, similar to the SMT-LIB logic, aimed at being used for first-order theorem proving. The modification includes formalisation of \verb'if'-\verb'then'-\verb'else' and \verb'let'-\verb'in' expressions and treatment of the boolean sort as a first class sort. This way the translation of certain program fragments with boolean values into logical statements become straightforward. The syntax and semantics of the logic is given in Section~\ref{sec:folbool}.
We further describe how \folb\ can be translated to the ordinary many-sorted first-order logic in Section~\ref{sec:folb-to-fol}.
Section~\ref{sec:superposition} discusses superposition-based theorem proving and proposes a new way of dealing with the boolean sort in it.
In Section~\ref{sec:tptp} we discuss the support of the boolean sort in TPTP and propose changes to it required to support a first-class boolean sort. We point out that such changes can also partially simplify the syntax of TPTP.
Section~\ref{sec:cicm15/related} discusses related work and Section~\ref{sec:cicm15/conclusions} contains concluding remarks.

The main contributions of this paper are the following:

\begin{enumerate}
\item the definition of \folb\ and its semantics;
\item a translation from \folb\ to first-order logic, which can be used to support \folb\ in existing first-order theorem provers;
\item a new technique of dealing with the boolean sort in superposition theorem provers, allowing one to replace boolean sort axioms by special rules;
\item a proposal of a change to the TPTP language, intended to support \folb\ and also simplify \ITE\ and \LETIN\ expressions.
\end{enumerate}
