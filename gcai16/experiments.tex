% !TEX root = main.tex

%Vampire is the first theorem prover to implement \newcnf{}. 
We extended Vampire's \newcnf{} clausification algorithm for standard FOL with our \nfcnf{} clausification algorithm for \folb{} formulas. 
The implementation of \nfcnf{} comprised about 500 lines of C++ code. 
%It will be included in the forthcoming official release of Vampire.
Our implementation, benchmarks and results are available at \url{www.cse.chalmers.se/~evgenyk/fool-cnf-experiments/}. 

% Our implementation is available at \url{www.cse.chalmers.se/~evgenyk/fool-cnf-experiments/} and will be included in the forthcoming official release of Vampire.

In what follows, we report on our experimental results obtained by running Vampire on \folb{} problems. 
Whenever we refer to Vampire, we mean the Vampire version extended with our new \nfcnf{} clausification algorithm for FOOL. 
We will write \oldcnfVampire{} for the previous version of Vampire
with the \oldcnf{} algorithm of~\cite{VampireAndFOOL};
\oldcnfVampire{} translates \folb{} formulas to FOL (after which they are clausified in a standard way)
and uses a special inference rule to avoid \folb{} self-paramodulation. 
% with the translation of \folb{} formulas to FOL presented in~\cite{FOOL}. In the sequel, by Vampire we will mean its version with the extended \newcnf{}. We will write %\oldcnfVampire{} for its version with the translation of \folb{} formulas to FOL and enabled \folb{} paramodulation~\cite{FOOL}.

For our experiments, we used three sets of benchmarks: 
(i) problems taken from~\cite{Blanchette15} on reasoning about (co)al\-ge\-braic datatypes (see Sect.~\ref{subsec:ADT}), 
(ii) examples with both quantifiers and uninterpreted functions taken from the SMT-LIB library~\cite{SMT-LIB} (see Sect.~\ref{subsec:SMT}), and
(iii) benchmarks on proving the partial correctness of loop-free programs (see Sect.~\ref{subsec:PrgAn}). The last benchmark suite is constructed by us to 
illustrate the use of FOOL in program analysis and verification. 
As Vampire is the only automated first-order theorem prover supporting FOOL, and in particular \ITE\ and \LETIN\ expressions, 
we could not compare Vampire with any other first-order prover. 
Further,  \oldcnfVampire{} did not yet support tuple expressions in
FOOL. Tuple expressions are also not supported by state-of-the-art SMT
solvers. For these reasons, we compared Vampire against \oldcnfVampire{}
and the SMT solvers CVC4~\cite{CVC4} and Z3~\cite{Z3}  only on the experiments from
Sect.~\ref{subsec:ADT}--\ref{subsec:SMT}.
%Our results are summarised in Tables~\ref{table:isabelle-results}--\ref{table:smt-lib-results2} and discussed below. 

%The first set is taken from our previous work~\cite{VampireAndFOOL} on the implementation of \folb{} in Vampire. The seconds set consists of problems from the SMT-LIB library~\cite{SMT-LIB}, a corpus of benchmarks for satisfiability modulo theory (SMT) solvers.
%
%In our previous work~\cite{VampireAndFOOL}, we experimented with our initial implementation of \folb{} in Vampire. 
%For that experiment, we generated two sets of \folb{} problems.
%\begin{enumerate}
 % \item Problems from the higher-order part of the TPTP library~\cite{TPTP} that can be directly expressed in \folb{}. We translated these problems from the TPTP language of higher-order logic to the modification of TPTP that supports \folb{}.
%  \item Problems about properties of (co)algebraic datatypes generated by the Isabelle theorem prover~\cite{Isabelle} to be checked by SMT solvers. We translated these problems from the SMT-LIB~2 language to TPTP using the SMTtoTPTP tool~\cite{SMTLIB2TPTP}.
%\end{enumerate}
%
%For this work we used the second set of problems only 
%as problems in the first set are easy and all of them were already solved by Vampire before.


\subsection{Experiments with Algebraic Datatypes Problems}\label{subsec:ADT}
We used 152 problems about (co)algebraic datatypes taken from~\cite{Blanchette15}. 
These examples were generated by Isabelle and translated by us to the TPTP syntax~\cite{TPTP}. 
These examples are expressed in \folb{}, as they use boolean variables occurring as formulas, formulas occurring as arguments to function and predicate symbols, and \ITE\ expressions. None of the 152 problems use \LETIN\ expressions.

We evaluated the performance of Vampire, \oldcnfVampire,
CVC4 and Z3 on the unsatisfiable problems in this set. In order to filter out satisfiable problems, we run all the provers on all the problems 
and only recorded the runs where at least one of the provers reported unsatisfiability. That gave us 57 problems.

We ran both Vampire and \oldcnfVampire\ with the option \verb'--mode casc'. For the runs of Vampire, the naming threshold was set to 8. We run CVC4 and Z3 with their default options.

Table~\ref{table:isabelle-results} summarises our results. They were obtained on a MacBook Pro with a 2,9 GHz Intel Core i5 and 8 Gb RAM, with a 60 seconds time limit for each benchmark. Vampire and \oldcnfVampire\ solved the largest number of problems, both provers solved the same problems. 51 problems were solved by all provers. Both Vampire and \oldcnfVampire\ solved 3 problems, not solved by either CVC4 or Z3. CVC4 and Z3 solved one problem, not solved by either Vampire or \oldcnfVampire. Compared to \oldcnfVampire, Vampire showed significantly smaller runtime. We therefore conclude that our clausification algorithm for FOOL improved the performance of Vampire on this set of problems.

\begin{table}[tb]
  \caption{Runtimes in seconds of provers on the set of 57 unsatisfiable algebraic datatypes problems.}
  \begin{center}
  \begin{tabular}{|l|r|r|}
    \hline
    Prover         & Solved & Total time on solved problems \\
    \hline
    Vampire        & 56     & 23.470 \\
    \oldcnfVampire & 56     & 31.121 \\
    Z3             & 53     & 3.615  \\
    CVC4           & 53     & 25.480 \\
    \hline
  \end{tabular}
  \end{center}
  \label{table:isabelle-results}
\end{table}

% \begin{figure}[tb]
%   %\vspace{-0.3em}
%   \centering
%   \begin{tikzpicture}
%     \draw (0,0) circle (1.5cm);
%     \draw (50:1cm) circle (1.55cm);
%     \draw (0cm:0.8cm) circle (1.4cm);
%     \node at (0.8cm:0.5cm) {$51$}; %
%     \node at (-2.2cm:1.2cm) {$1$};
%     \node at (1cm:-1.1cm) {$0$};
%     \node at (-2cm:-1.1cm) {$1$};
%     \node at (-3.8cm:-1.9cm) {$3$}; %
%     \node at (-0.95cm:1.775cm) {$0$}; %
%     \node at (0.45cm:1.775cm) {$1$}; %
%     \node at (2.7cm:2.65cm) {Vampire};
%     \node at (-3.7cm:1.8cm) {Z3};
%     \node at (-1.6cm:2.3cm) {CVC4};
%   \end{tikzpicture}
%   \vspace{-0.3em}
%   \caption{Venn diagram of the subsets of the algebraic datatypes problems, solved by Vampire, CVC4 and Z3.}
%   \label{fig:isabelle-diagram}
% \end{figure}

\subsection{Experiments with SMT-LIB Problems}\label{subsec:SMT}

As explained in more detail later on (see Section~\ref{sec:related}), \folb{} can be regarded as a superset of the SMT-LIB core logic.
% \folb{} can be regarded as a superset of SMT-LIB core logic and problems of SMT-LIB core logic can be directly expressed in \folb{}. The language of \folb{} extends the SMT-LIB core language with local function definitions, using \LETIN\ expressions defining functions of arbitrary, and not just zero, arity. 
A theorem prover that supports \folb{} can be straightforwardly extended to read problems written in the SMT-LIB syntax.
%
For our experiments using SMT-LIB problems, we used problems in quantified predicate logic with uninterpreted functions stored in the UF subspace of SMT-LIB.
These problems use \ITE\ expressions, \LETIN\ expressions that define constants, and formulas 
occurring as arguments to equality. None of the problems use quantifiers over the boolean sort. 
 The  problems taken from SMT-LIB are written in the SMT-LIB~2
 syntax. In order to read these problems, we implemented a parser for
 a sufficient subset of the SMT-LIB~2 language in Vampire. The
 implementation of the parser comprised about 2,500 lines of C++ code. 

We evaluated the performance of Vampire, \oldcnfVampire, and CVC4 on unsatisfiable problems of the UF subspace. Each problem in the SMT-LIB library is marked with one of the statuses \verb'sat', \verb'unsat' and \verb'unknown'. A problem is marked as \verb'sat' or \verb'unsat' 
when at least two SMT solvers proved it to be satisfiable or unsatisfiable, respectively.
Otherwise, a problem is marked as \verb'unknown'. In order to filter out satisfiable problems,
we ran Vampire, \oldcnfVampire, and CVC4 on the problems marked as \verb'unsat' and \verb'unknown' and then recorded the results on the problems that were proven unsatisfiable by at least one prover. That gave us 2191 problems.


We ran Vampire twice on each problem: once with naming of \LETIN\ expressions and once with inlining (see Sect.~\ref{subsect:letin}).
For each run the naming threshold was set to 8. In both runs we also used the option \verb'--mode casc'. For each problem, we recorded the fastest successful run of Vampire. We ran \oldcnfVampire\ once on each problem with the option \verb'--mode casc'.

\begin{table}[tb]
  \caption{Runtimes in seconds of provers on the set of 2191 unsatisfiable SMT-LIB problems.}
  \begin{center}
  \begin{tabular}{|l|r|r|r|}
    \hline
    Prover         & Solved & Uniquely solved & Total time on solved problems \\
    \hline
    CVC4           & 2084   & 55              & 26,309.47 \\
    Vampire        & 2076   & 12              & 22,920.50 \\
    \oldcnfVampire & 1984   & 9               & 19,911.69 \\
    Z3             & 1729   & 4               & 18,102.96 \\
    \hline
  \end{tabular}
  \end{center}
  \label{table:smt-lib-results2}
\end{table}

% \begin{figure}[tb]
%   \centering
%   \begin{tikzpicture}
%     \draw (0,0) circle (1.5cm);
%     \draw (50:1.5cm) circle (1.6cm);
%     \draw (0cm:1.3cm) circle (1.45cm);
%     \node at (0.8cm:0.75cm) {$1885$}; %
%     \node at (-1.85cm:1.05cm) {$9$};
%     \node at (0.8cm:-0.8cm) {$91$};
%     \node at (-2.8cm:-1.0cm) {$99$};
%     \node at (-4.1cm:-2.3cm) {$12$}; %
%     \node at (-0.75cm:2cm) {$10$}; %
%     \node at (0.65cm:1.95cm) {$80$}; %
%     \node at (2.55cm:3.2cm) {Vampire};
%     \node at (-3.7cm:1.8cm) {CVC4};
%     \node at (-1.6cm:2.4cm) {\oldcnfVampire};
%   \end{tikzpicture}
%   \vspace{-0.3em}
%   \caption{Venn diagram of the subsets of the 2191 unsatisfiable SMT-LIB problems, solved by Vampire, \oldcnfVampire\ and CVC4.}
%   \label{fig:smt-lib-newcnf-diagram}
% \end{figure}

Table~\ref{table:smt-lib-results2} summarises the results of our experiments on the SMT-LIB problems. These results were obtained on the StarExec compute cluster~\cite{starexec} using the time limit of 5 minutes per problem. 
CVC4 solved the largest number of problems, Vampire solved significantly more than \oldcnfVampire, and Z3 solved the least number of problems. None of the provers solved a superset of problems solved by another prover. The ``Uniquely solved'' column of Table~\ref{table:smt-lib-results2} shows the number of problems that were solved by each of the provers, but not any of the other ones. 1675 problems were solved by all of the provers, and 2190 problems were solved by at least one of the provers. Vampire solved 111 problems not solved by \oldcnfVampire, and \oldcnfVampire\ solved 19 problems not solved by Vampire.

We also recorded how different translations of \LETIN\ affected the performance of Vampire. Vampire with inlining of \LETIN\ expressions solved 61 problems not solved by Vampire without inlining of \LETIN\ expressions. Vampire without inlining of \LETIN\ expressions solved 45 problems not solved by Vampire without inlining of \LETIN\ expressions.
%\todo{Does it mean the Venn diagram reports the parallel best of these two versions?} EK: yes, it says so two paragraphs before

Based on the results of this experiment we make the following observations. Vampire solved new problems by inlining \LETIN\ expressions and expanding \ITE\ expressions. Vampire could not solve some of the problems that were solved by \oldcnfVampire, we explain it by the fact that \oldcnfVampire\ always names \ITE\ expressions, which turns out to be important for solving some problems. Both inlining and naming of \LETIN\ expressions can make a prover inefficient.