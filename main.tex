\documentclass[10pt,twoside]{book}
\usepackage{amssymb,amsmath,amsthm,mathrsfs,stmaryrd,dsfont,bbold,mathtools}
\usepackage[english]{babel}
\usepackage[lighttt]{lmodern}
\usepackage[inline]{enumitem}
\usepackage{yfonts}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{color}
\usepackage{proof}
\usepackage{url}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{wrapfig}

\include{layout}

\include{notation}

\include{information}

\newcommand{\EK}[1]{{\color{red}  EK: {#1}}}

\begin{document}

\frontmatter

\maketitle

\chapter*{Abstract}
\input{abstract}

\tableofcontents

% \chapter*{Acknowledgements}
% \input{acknowledgements}

\mainmatter

\chapter{Introduction}
\label{chap:intro}
\input{introduction}

\def\paperOneContentsTitle{A First Class Boolean Sort in\\First-Order Theorem Proving and TPTP}
\def\paperOneChapterTitle{A First Class Boolean Sort in\\First-Order Theorem Proving\\and TPTP}
\def\paperOneAuthors{Evgenii~Kotelnikov, Laura~Kov\'acs and Andrei~Voronkov}
\def\paperOneAbstract{To support reasoning about properties of programs operating with boolean values one needs theorem provers to be able to natively deal with the boolean sort. This way, program properties can be translated to first-order logic and theorem provers can be used to prove program properties efficiently. However, in the TPTP language, the input language of automated first-order theorem provers, the use of the boolean sort is limited compared to other sorts, thus hindering the use of first-order theorem provers in program analysis and verification. In this paper, we present an extension \folb\ of many-sorted first-order logic, in which the boolean sort is treated as a first-class sort. Boolean terms are indistinguishable from formulas and can appear as arguments to functions. In addition, \folb\ contains \ITE\ and \LETIN\ constructs. We define the syntax and semantics of \folb\ and its model-preserving translation to first-order logic. We also introduce a new technique of dealing with boolean sorts in superposition-based theorem provers. Finally, we discuss how the TPTP language can be changed to support \folb.}
\def\paperOnePublication{Published in the \emph{Proceedings of the 8th Conference on Intelligent\\Computer Mathematics}, pages 71--86. Springer, 2015.}
\paperchapter{\paperOneContentsTitle}
             {\paperOneChapterTitle}
             {\paperOneAuthors}
             {\paperOneAbstract}
             {\paperOnePublication}
\label{chap:fool}
\include{cicm15/main}

\def\paperTwoContentsTitle{The Vampire and the FOOL}
\def\paperTwoChapterTitle{The Vampire and the FOOL}
\def\paperTwoAuthors{Evgenii~Kotelnikov, Laura~Kov\'{a}cs,\\Giles~Reger and Andrei~Voronkov}
\def\paperTwoAbstract{This paper presents new features recently implemented in the theorem prover Vampire, namely support for first-order logic with a first class boolean sort (\folb{}) and polymorphic arrays. In addition to having a first class boolean sort, \folb{} also contains \ITE\ and \LETIN\ expressions. We argue that presented extensions facilitate reasoning-based program analysis, both by increasing the expressivity of first-order reasoners and by gains in efficiency.}
\def\paperTwoPublication{Published in the \emph{Proceedings of the 5th ACM SIGPLAN Conference on Certified Programs and Proofs}, pages 37--48. ACM New York, 2016.}
\paperchapter{\paperTwoContentsTitle}
             {\paperTwoChapterTitle}
             {\paperTwoAuthors}
             {\paperTwoAbstract}
             {\paperTwoPublication}
\label{chap:implementation}
\include{cpp16/main}

\def\paperThreeContentsTitle{A Clausal Normal Form Translation for \folb{}}
\def\paperThreeChapterTitle{A Clausal Normal Form\\Translation for \folb{}}
\def\paperThreeAuthors{Evgenii~Kotelnikov, Laura~Kov\'{a}cs,\\Martin~Suda and Andrei~Voronkov}
\def\paperThreeAbstract{Automated theorem provers for first-order logic usually operate on sets of first-order clauses. It is well-known that the translation of a formula in full first-order logic to a clausal normal form (CNF) can crucially affect performance of a theorem prover. In our recent work we introduced a modification of first-order logic extended by the first class boolean sort and syntactical constructs that mirror features of programming languages. We called this logic FOOL. Formulas in FOOL can be translated to ordinary first-order formulas and checked by first-order theorem provers. While this translation is straightforward, it does not result in a CNF that can be efficiently handled by state-of-the-art theorem provers which use superposition calculus. In this paper we present a new CNF translation algorithm for FOOL that is friendly and efficient for superposition-based first-order provers. We implemented the algorithm in the Vampire theorem prover and evaluated it on a large number of problems coming from formalisation of mathematics and program analysis. Our experimental results show an increase of performance of the prover with our CNF translation compared to the naive translation.}
\def\paperThreePublication{Published in the \emph{Proceedings of the 2nd Global Conference on Artificial Intelligence}, pages 53--71. EPiC Series in Computing, 2016.}
\paperchapter{\paperThreeContentsTitle}
             {\paperThreeChapterTitle}
             {\paperThreeAuthors}
             {\paperThreeAbstract}
             {\paperThreePublication}
\label{chap:cnf}
\include{gcai16/main}

\def\paperFourContentsTitle{A FOOLish Encoding of the Next State Relations\\of Imperative Programs}
\def\paperFourChapterTitle{A FOOLish Encoding of the Next State Relations of Imperative Programs}
\def\paperFourAuthors{Evgenii~Kotelnikov, Laura~Kov\'{a}cs and Andrei~Voronkov}
\def\paperFourAbstract{Automated theorem provers are routinely used in program analysis and verification for checking program properties. These properties are translated from program fragments to formulas expressed in the logic supported by the theorem prover. Such translations can be complex and require deep knowledge of how theorem provers work in order for the prover to succeed on the translated formulas. Our previous work introduced FOOL, a modification of first-order logic that extends it with syntactical constructs resembling features of programming languages. One can express program properties directly in FOOL and leave translations to plain first-order logic to the theorem prover. In this paper we present a FOOL encoding of the next state relations of imperative programs. Based on this encoding we implement a translation of imperative programs annotated with their pre- and post-conditions to partial correctness properties of these programs. We present experimental results that demonstrate that program properties translated using our method can be efficiently checked by the first-order theorem prover Vampire.}
\def\paperFourPublication{Published in \EK{TODO: IJCAR 2018}}
\paperchapter{\paperFourContentsTitle}
             {\paperFourChapterTitle}
             {\paperFourAuthors}
             {\paperFourAbstract}
             {\paperFourPublication}
\label{chap:boogie}
\include{ijcar18/main}

\bibliography{refs}

\end{document}