% !TEX root = ../main.tex

Automated theorem provers for first-order logic usually operate on sets of first-order clauses. In order to check a formula in full first-order logic, theorem provers first translate it to clausal normal form (CNF). It is well-known that the quality of this translation affects the performance of the theorem prover. While there is no absolute criterion of what the best CNF for a formula is, theorem provers usually try to make the CNF smaller according to some measure. This measure can include the number of clauses, the number of literals, the lengths of the clauses and the size of the resulting signature, i.e.~the number of function and predicate symbols. Implementors of CNF translations commonly employ formula simplification~\cite{nonnengart2001computing}, (generalised) formula naming~\cite{nonnengart2001computing,azmy2013computing}, and other clausification techniques, aimed to make the CNF smaller.

Our recent work~\cite{FOOL} presented a modification of many-sorted first-order with first-class boolean sort. We called this logic \folb{}, standing for first-order logic (FOL) with boolean sort. \folb{} extends FOL by (i) treating boolean terms as formulas; (ii) \ITE\ expressions; and (iii) \LETIN\ expressions. There is a model-preserving translation of \folb{} formulas to FOL that works by replacing parts of a \folb{} formula with applications of fresh function and predicate symbols and extending the set of assumptions with definitions of these symbols. We implemented~\cite{VampireAndFOOL} this translation in the Vampire theorem prover~\cite{Vampire13}. To check a \folb{} problem Vampire first translates it to first-order logic, then converts the resulting first-order formulas to a set of clauses.

%This translation can be used in first-order provers to support reasoning about \folb\ problems. We implemented~\cite{VampireAndFOOL} it in the Vampire theorem prover~\cite{Vampire13}. In that implementation, a \folb\ formula is first translated to first-order logic, then Vampire translates the resulting first-order formulas to first-order clauses and checks them.

%While the translation from~\cite{FOOL} provides an easy way to support \folb{} in existing first-order provers, it is not necessarily friendly to superposition. A \folb{} formula is translated to a set of first-order clauses in two steps rather than directly. That way, we miss out on the opportunity to specialise the translation and integrate existing clausification techniques into it. By Some \folb{} formulas can be translated to smaller CNFs than we obtain

While the translation from~\cite{FOOL} provides an easy way to support \folb{} in existing first-order provers, it is not necessarily efficient. A more efficient translation can convert a \folb{} formula directly to a set of first-order clauses, skipping the intermediate step of converting it to full first-order logic. This way, the translation can integrate known clausification techniques and improve the quality of the resulting clausal normal form. % We observed that the CNFs that we obtain from some \folb{} formulas with this translation are unnecessarily large, and it can damage the performance of the prover. We believe that this is due to the fact that \folb{} formulas are translated to CNF in two steps rather than directly. This way, we miss out on the opportunity to specialise the translation and integrate existing clausification techniques into it.


%While the translation from~\cite{FOOL} provides an easy way to support \folb{} in existing first-order provers, it is not necessarily friendly to superposition. We observed that the CNFs that we obtain from some \folb{} formulas with this translation are unnecessarily large, and it can damage the performance of the prover. We believe that this is due to the fact that \folb{} formulas are translated to CNF in two steps rather than directly. This way, we miss out on the opportunity to specialise the translation and integrate existing clausification techniques into it.

In this work we present a clausification algorithm that translates a \folb{} formula to an equisatisfiable set of first-order clauses. This algorithm aims to minimise the number of clauses and the size of the resuting signature, especially on formulas with \ITE, \LETIN\ expressions and complex boolean structure. This ultimately leads to an increase of performance of a theorem prover that implements it compared e.g. to the use of the translation to full first-order logic from~\cite{FOOL}.

Our algorithm is an extension of the \newcnf~\cite{newcnf_fol} clausification algorithm\footnote{The name \newcnf{} is tentative and is likely to be changed before the publication of~\cite{newcnf_fol}.} for first-order logic that enables it to translate \folb{} formulas. Section~\ref{sec:newcnf/cnf} revisits the essentials of \newcnf{} which are required for our extension presented in Section~\ref{sec:newcnf/fool}. Our algorithm combines translation of \folb{} formulas to first-order logic and clausification. In Section~\ref{sec:newcnf/comparison} we discuss how integrating clausification techniques help to produce smaller clausal normal forms. Section~\ref{sec:newcnf/experiments} describes the experiments on theorem proving with FOOL formulas using different translations. Finally, Section~\ref{sec:newcnf/conclusions} outlines future work.

The main contributions of this paper are the following:
\begin{enumerate}
  \item a clausification algorithm that translates a \folb{} formula to an equisatisfiable set of first-order clauses;
  \item an implementation of this algorithm in the Vampire theorem prover;
  \item experimental results that demonstrate an increase of performance of Vampire on \folb{} problems compared to its version with the translation of \folb{} formulas to first-order logic presented in~\cite{FOOL}.
\end{enumerate}