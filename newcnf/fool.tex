This section presents a clausification algorithm for \folb{}. This algorithm takes a \folb{} formula as input and produces a set of first-order clauses. The conjunction of these clauses is equisatisfiable to the input formula.

\folb{} extends many-sorted first-order logic with an interpreted boolean sort and the following syntactical constructs:
\begin{enumerate}
  \item boolean variables used as formulas;
  \item formulas used as arguments to function and predicate symbols;
  \item \ITE\ expressions that can occur as terms and formulas;
  \item \LETIN\ expressions that can occur as terms and formulas and can define an arbitrary number of function and predicate symbols.
\end{enumerate}

There are several ways to support the interpreted boolean sort in a first-order logic. The approach taken in~\cite{FOOL} proposes to axiomatise it by adding two constants $\true$ and $\false$ of this sorts and two axioms: $\true \neql \false$ and $(\forall x:\bool)(x \eql \true \lor x \eql \false)$. Furthermore, \cite{FOOL} proposed a modification of superposition calculus that included a replacement of the second axiom with the specialised \folb{} paramodulation rule. This modification prevents possible performance problems of a superposition theorem prover caused by self-paramodulation of $x \eql \true \lor x \eql \false$. The translation to first-order clauses presented in this section does not require boolean axioms or modifications of superposition calculus to correctly support the boolean sort. This property is explained at the end of this section.

Our algorithm is an extension of \newcnf{} that adds support for \folb{} formulas. In order to enable \newcnf{} to translate \folb{} and not just first-order formula we make the following changes to it.
\begin{itemize}
  \item We allow intermediate clauses to contain signed \folb{} formulas, and not just first-order formulas.
  \item We extend the \newcnf{} tautology elimination with the support for boolean variables. Whenever a boolean variable occurs in an intermediate clause twice with the opposite signs, that intermediate clause is not added to $\GC$. Whenever a boolean variable occurs in an intermediate clause multiple times with the same sign, only one occurrence is kept in the intermediate clause.
  \item We add extra rules that guide how intermediate clauses are replaced in the set $\GC$, detailed below. These rules correspond to syntactical constructs available in \folb{} but not in ordinary first-order logic.
  \item We change the rule that translates existentially quantified formulas to skolemise boolean variables using Skolem predicates and not Skolem functions. For that, we also allow substitutions to map boolean variables to Skolem literals. 
  \item We add an extra step of translation. After the input formula has been traversed, we apply substitutions of boolean variables to every formula in each respective intermediate clause. The resulting set of intermediate clauses might have Skolem literals occurring as terms. We run the clausification algorithm again on this set of intermediate clauses. The second run does not introduce new substitutions and results with a set of intermediate clauses that only contains atomic formulas and substitutions of non-boolean variables.
\end{itemize}

We extend the rules of replacing intermediate clauses with the cases detailed below. We will not distinguish formulas used as arguments as a separate syntactical construct, but rather treat each such formula $\phi$ as an \ITE\ expression of the form $\ite{\phi}{\true}{\false}$. We will assume that every \LETIN\ expression defines exactly one function or predicate symbol. Every \LETIN\ expression that defines more that one symbol can be transformed to multiple nested \LETIN\ expressions, each defining a single symbol, possibly by renaming some of the symbols. Moreover, we will assume that \LETIN\ expressions only occur as formulas. Every formula that contains a \LETIN\ expression that occurs as non-boolean term can be transformed to a \LETIN\ expression that defines the same symbol and occurs as formula. % EK: Should be careful with let inside let bindings!

Let $\psi$ be a subformula of the input formula $\phi$ and $\genclause{C}{\subst}$ be an intermediate clause such that $C$ has an occurrence of $\genlit{\psi}{\sign}$.
\begin{itemize}
  \item
    Suppose that $\psi$ is a boolean variable $x$. If $\subst$ does not map $x$, add the intermediate clause $\genclause{C'}{\subst'}$ to $\GC$, where $C'$ is obtained from $C$ by removing the occurrence of $\genlit{\psi}{\sign}$ and $\subst'$ extends $\subst$ with $x \mapsto \false$ if $\sign=\possign$, and $x \mapsto \true$ if $\sign=\negsign$. If $\subst$ does map $x$, add $\genclause{C}{\subst}$ to $\GC$. 

  \item
    Suppose that $\psi$ is $\gamma_1 \eql \gamma_2$, where $\gamma_1$ and $\gamma_2$ are formulas. Add two intermediate clauses to $\GC$ obtained from $C$ by replacing the occurrence of $\psi$ with $\genlit{\gamma_1}{-\sign}$, $\genlit{\gamma_2}{\possign}$ and $\genlit{\gamma_1}{\sign}$, $\genlit{\gamma_2}{\negsign}$, respectively.

  \item
    Suppose that $\psi$ is $\ite{\chi}{\gamma_1}{\gamma_2}$. Add two intermediate clauses to $\GC$ obtained from $C$ by replacing the occurrence of $\genlit{\psi}{\sign}$ with $\genlit{\chi}{\negsign}$, $\genlit{\gamma_1}{\sign}$ and $\genlit{\chi}{\possign}$, $\genlit{\gamma_2}{\sign}$, respectively.

  \item
    Suppose that $\psi$ is an atomic formula that contains one or more \ITE\ expressions occurring as terms. Each of the \ITE\ expressions is translated in one of two ways, either by expanding or by naming. We will describe both ways for a single \ITE\ expressions and then generalise for an arbitrary number of \ITE\ expressions. Suppose that $\psi$ is an atomic formula $L[\ite{\gamma}{s}{t}]$.

    \paragraph{Expanding.} Add two intermediate clauses to $\GC$ obtained from $C$ by replacing the occurrence of $\genlit{\phi}{\sign}$ with $\genlit{\gamma}{\negsign}$, $\genlit{L[s]}{\sign}$ and $\genlit{\gamma}{\possign}$, $\genlit{L[t]}{\sign}$, respectively.
    
    \paragraph{Naming.} Let $x_1,\ldots,x_n$ be all free variables of $\phi$, and $\tau_1,\ldots,\tau_n$ be their sorts. Let $\tau$ be be the sort of both $s$ and $t$. Then,
    \begin{enumerate}
      \item introduce a fresh predicate symbol $P$ of the sort $\tau\times\tau_1\times\ldots\times\tau_n$;
      \item introduce a fresh variable $y$ of the sort $\tau$;
      \item add an intermediate clause to $\GC$ that is obtained from $C$ by replacing the occurrence of $\genlit{\psi}{\sign}$ with $\genlit{L[y]}{\sign}$, $\genlit{P(y,x_1,\ldots,x_n)}{\negsign}$;
      \item add intermediate clauses $\genclause{\{\genlit{\gamma}{\negsign},\genlit{P(s,x_1,\ldots,x_n)}{\possign}\}}{\emptySubst}$ and\\$\genclause{\{\genlit{\gamma}{\possign},\allowbreak\genlit{P(t,\allowbreak x_1,\allowbreak \ldots,x_n)}{\possign}\}}{\emptySubst}$ to $\GC$.
    \end{enumerate}

    In order to eliminate all \ITE\ expressions we apply either expanding or naming to each of the \ITE\ expressions. We assume that a pre-specified expansion threshold limits the maximal number of expanded \ITE\ expressions inside one atomic formula. We start by expanding all \ITE\ expression and once the expansion threshold is reached, name the remaining \ITE\ expressions.

  \item
    Suppose that $\psi$ is $\letin{f(x_1:\sigma_1,\ldots,x_n:\sigma_n)}{t}{\gamma}$. It is translated in one of two ways, either by inlining or by naming. The choice of inlining or naming of \LETIN\ expressions in the problem is determined by a pre-specified boolean option. % provided by the user of the algorithm.
    
    \paragraph{Inlining.} Add an intermediate clause to $\GC$ that is obtained from $C$ by replacing the occurrence of $\genlit{\psi}{\sign}$ with $\genlit{\gamma'}{\sign}$. $\gamma'$ is obtained from $\gamma$ by replacing each application $f(t_1,\ldots,t_n)$ of a free occurrence of $f$ in $\gamma$ with $t'$, that is obtained from $t$ by replacing each free occurrence of $x_1,\ldots,x_n$ in $t$ with $t_1,\ldots,t_n$, respectively. We point out that inlining predicate symbols of zero arity does not hinder identification of tautologies thanks to intermediate tautology removal inside intermediate clauses.

    \paragraph{Naming.} Add an intermediate clause to $\GC$ that is obtained from $C$ by replacing the occurrence of $\genlit{\psi}{\sign}$ with $\genlit{\gamma}{\sign}$. Let $\tau$ be the sort of $t$. If $\tau$ is $\bool$, add intermediate clauses $\genclause{\{\genlit{f(x_1,\ldots,x_n)}{\negsign},\genlit{t}{\possign}\}}{\emptySubst}$ and $\genclause{\{\genlit{f(x_1,\ldots,x_n)}{\possign},\genlit{t}{\negsign}\}}{\emptySubst}$ to $\GC$. Otherwise, add an intermediate clause $\genclause{\{f(x_1,\ldots,x_n) \eql t\}}{\emptySubst}$ to $\GC$.
\end{itemize}

The extra step of translation that eliminates Skolem literals occurring as terms amounts to application of the expansion threshold-based procedure for \ITE\ expressions.

The extended \newcnf{} algorithm produces a set of first-order clauses. This set does not require boolean axioms to be equisatisfiable to the original \folb{} formula. The resulting set of clauses has the following two properties.
\begin{enumerate}
  \item It can only contain boolean variables and constants $\true$ and $\false$ as boolean terms. Every boolean term that occurs in $\phi$ is translated as formula and no boolean terms other than variables, $\true$ and $\false$ are introduced. 
  \item It does not contain equalities between boolean terms. Every boolean equality occurring in the input is translated as equivalence between its arguments, and no new boolean equalities are introduced.
\end{enumerate}
These two properties ensure that boolean variables will only be unified with $\true$ and $\false$ during superposition. Constants $\true$ and $\false$ cannot be unified with each other, therefore no logical inference can violate the properties of the boolean sort. % TODO: A more accurate argument is needed here!